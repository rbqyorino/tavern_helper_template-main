'use strict';\n\n(function () {\n  const config = {\n    defaultBackground: '',\n    typewriterSpeed: 30,\n    renderDepth: 1,\n    characterBottomOffset: -34, \n    dialogueHeight: 22, // 对话框高度百分比\n    mobileDiaogueHeight: 40, // 移动端对话框高度百分比\n    debug: false,\n  };\n\n  // 图片别名管理\n  const imageAliasManager = (function () {\n    let aliases = {};\n    let aliasesLoaded = false;\n\n    async function loadImageAliases() {\n      try {\n        if (typeof getCurrentCharPrimaryLorebook !== 'function') {\n          initDefaultAliases();\n          aliasesLoaded = true;\n          return;\n        }\n\n        const charLorebookName = await getCurrentCharPrimaryLorebook();\n        if (!charLorebookName) {\n          initDefaultAliases();\n          aliasesLoaded = true;\n          return;\n        }\n\n        const allEntries = await getLorebookEntries(charLorebookName);\n        aliases = {};\n\n        const imageTypeRegex = /^图片-/;\n        const imageEntries = allEntries.filter(\n          entry => entry.comment && imageTypeRegex.test(entry.comment) && entry.enabled === true,\n        );\n\n        if (imageEntries.length === 0) {\n          initDefaultAliases();\n          aliasesLoaded = true;\n          return;\n        }\n\n        for (const entry of imageEntries) {\n          parseImageAliasEntry(entry.content);\n        }\n\n        aliasesLoaded = true;\n      } catch (error) {\n        initDefaultAliases();\n        aliasesLoaded = true;\n      }\n    }\n\n    async function waitForAliasesLoaded() {\n      if (aliasesLoaded) return true;\n\n      const maxWait = 2000;\n      const startTime = Date.now();\n\n      return new Promise(resolve => {\n        const checkLoaded = () => {\n          if (aliasesLoaded) {\n            resolve(true);\n            return;\n          }\n\n          if (Date.now() - startTime > maxWait) {\n            resolve(false);\n            return;\n          }\n\n          setTimeout(checkLoaded, 100);\n        };\n\n        checkLoaded();\n      });\n    }\n\n    function parseImageAliasEntry(content) {\n      if (!content) return;\n\n      const regex = /<([^|]+)\\|([^|>]+)>/g;\n      let match;\n\n      while ((match = regex.exec(content)) !== null) {\n        const alias = match[1].trim();\n        const url = match[2].trim();\n\n        if (alias && url) {\n          aliases[alias] = url;\n        }\n      }\n    }\n\n    function initDefaultAliases() {\n      aliases = {\n        少女: '',\n        男孩: '',\n        背景1: '',\n        背景2: '',\n        背景A: '',\n        背景B: '',\n        角色A立绘: '',\n        角色B立绘: '',\n      };\n    }\n\n    function processImageTag(input) {\n      if (!input) return input;\n\n      const tagRegexes = {\n        char: /\\[char\\|([^\\]]+)\\]/,\n        bg: /\\[bg\\|([^\\]]+)\\]/,\n        cg: /\\[cg\\|([^\\]]+)\\]/,\n      };\n\n      for (const type in tagRegexes) {\n        const match = tagRegexes[type].exec(input);\n        if (match) {\n          const alias = match[1].trim();\n          const imgUrl = aliases[alias];\n          if (imgUrl) {\n            return { url: imgUrl, type: type };\n          }\n          return { url: null, type: type };\n        }\n      }\n\n      return input;\n    }\n\n    function isValidUrl(url) {\n      if (!url) return false;\n\n      if (typeof url === 'string') {\n        if (url.includes('[char|') || url.includes('[bg|') || url.includes('[cg|')) {\n          const imgTagRegex = /\\[(char|bg|cg)\\|([^\\]]+)\\]/;\n          const match = url.match(imgTagRegex);\n          if (match) {\n            const alias = match[2].trim();\n            return !!aliases[alias];\n          }\n        }\n      }\n\n      return url.startsWith('http://') || url.startsWith('https://');\n    }\n\n    function getImageUrl(input) {\n      if (!input) return null;\n\n      if (typeof input === 'string') {\n        const imgTagRegex = /\\[(char|bg|cg)\\|([^\\]]+)\\]/;\n        const match = input.match(imgTagRegex);\n        if (match) {\n          const type = match[1];\n          const alias = match[2].trim();\n          if (aliases[alias]) {\n            return {\n              url: aliases[alias],\n              type: type,\n            };\n          }\n        }\n      }\n\n      if (typeof input === 'string' && (input.startsWith('http://') || input.startsWith('https://'))) {\n        return {\n          url: input,\n          type: 'char',\n        };\n      }\n\n      if (typeof input === 'string') {\n        const aliasUrl = aliases[input.trim()];\n        if (aliasUrl) {\n          return {\n            url: aliasUrl,\n            type: 'char',\n          };\n        }\n      }\n\n      return input;\n    }\n\n    function setAlias(alias, url) {\n      if (alias && url) {\n        aliases[alias.trim()] = url.trim();\n        return true;\n      }\n      return false;\n    }\n\n    function getAliases() {\n      return aliases;\n    }\n\n    initDefaultAliases();\n\n    loadImageAliases();\n\n    return {\n      getImageUrl,\n      setAlias,\n      isValidUrl,\n      processImageTag,\n      loadImageAliases,\n      waitForAliasesLoaded,\n      getAliases,\n    };\n  })();\n\n  // 集中处理错误的辅助函数\n  async function safeExecute(fn, fallback = null, errorMessage = '操作执行出错') {\n    try {\n      return await fn();\n    } catch (error) {\n      log(errorMessage, error);\n      return fallback;\n    }\n  }\n\n  // 记录日志\n  function log(...args) {\n    if (\n      config.debug &&\n      args[0] &&\n      typeof args[0] === 'string' &&\n      (args[0].includes('出错') || args[0].includes('失败') || args[0].includes('错误'))\n    ) {\n      console.log('[GALGAME插件]', ...args);\n    }\n  }\n\n  // 文本格式化处理函数\n  function renderText(text) {\n    if (!text) return '';\n\n    try {\n      // 转换星号包围的文本为斜体\n      text = text.replace(/\\*{1}(.+?)\\*{1}/g, '<em>$1</em>');\n\n      // 转换引号包围的文本，移除引号\n      text = text.replace(/\\\"{1}(.+?)\\\"{1}/g, '$1');\n\n      return text;\n    } catch (error) {\n      log('格式化文本错误:', error);\n      return text || '';\n    }\n  }\n\n  const gameTextRegex = /```\\S*\\s*<gametext>([\\s\\S]*?)<\\/gametext>\\s*```/is;\n  const directGameTextRegex = /<gametext>([\\s\\S]*?)<\\/gametext>/is;\n\n  const dialogueRegex = /^([^|]*)\\|([^|]*)\\|([^|]*)\\|(.*)$/;\n  const commandRegex = /^\\[(.+?)\\]$/;\n\n  const renderedMessages = new Set();\n\n  const gameStates = {};\n\n  let streamStart = false;\n  let streamParsing = false;\n  let streamInfo = undefined;\n  let tempMesText = null;\n\n  async function renderGameForMessage(messageId) {\n    if (renderedMessages.has(messageId)) return;\n\n    if (config.renderDepth > 0) {\n      const lastMessageId = await getLastMessageId();\n      if (lastMessageId - Number(messageId) >= config.renderDepth) {\n        return;\n      }\n    }\n\n    const messages = await getChatMessages(messageId);\n    if (messages.length === 0) {\n      return;\n    }\n\n    const messageContent = messages[0].message;\n    if (!messageContent) {\n      return;\n    }\n\n    let scriptText = '';\n    const scriptMatch = messageContent.match(gameTextRegex);\n\n    if (scriptMatch) {\n      scriptText = scriptMatch[1].trim();\n    } else {\n      const directMatch = messageContent.match(directGameTextRegex);\n      if (!directMatch) {\n        return;\n      }\n\n      scriptText = directMatch[1].trim();\n    }\n\n    if (!scriptText) {\n      return;\n    }\n\n    await imageAliasManager.waitForAliasesLoaded();\n\n    return renderGameContent(messageId, scriptText);\n  }\n\n  async function renderGameContent(messageId, scriptText) {\n    const messageElement = retrieveDisplayedMessage(messageId);\n    if (!messageElement || messageElement.length === 0) {\n      return;\n    }\n\n    const gameData = parseScript(scriptText);\n\n    const gameHTML = createGameHTML(messageId, gameData);\n\n    messageElement.find('pre, code, .roleplay_galgame').remove();\n\n    messageElement.append(gameHTML);\n\n    setupGameEvents(messageId, gameData);\n\n    renderedMessages.add(messageId);\n  }\n\n  function parseScript(scriptText) {\n    try {\n      const lines = scriptText.trim().split('\\n');\n      const gameData = {\n        scenes: [],\n        currentSceneIndex: 0,\n      };\n\n      let tempScenes = [];\n      let currentExecutableIndex = 0;\n\n      lines.forEach(line => {\n        line = line.trim();\n        if (!line) return;\n\n        const commandMatch = line.match(/^\\[(.+?)\\]$/);\n        if (commandMatch) {\n          const fullCommand = commandMatch[1];\n          const parts = fullCommand.split('|');\n\n          const command = parts[0].trim();\n\n          const args = parts.slice(1).map(arg => arg.trim());\n\n          tempScenes.push({\n            type: 'command',\n            command,\n            args,\n            original: line,\n          });\n          currentExecutableIndex++;\n          return;\n        }\n\n        const dialogueMatch = line.match(/^([^|]*)\\|([^|]*)\\|([^|]*)\\|(.*)$/);\n        if (dialogueMatch) {\n          let spriteImg = dialogueMatch[3].trim();\n\n          let text = dialogueMatch[4].trim();\n          const inlineActionMatch = text.match(/(.*?)(\\[action\\|.+?\\])$/);\n          let inlineAction = null;\n\n          if (inlineActionMatch) {\n            text = inlineActionMatch[1].trim();\n            const actionCommandMatch = inlineActionMatch[2].match(/^\\[(.+?)\\]$/);\n            if (actionCommandMatch) {\n              const actionParts = actionCommandMatch[1].split('|');\n\n              inlineAction = {\n                target: actionParts[1].trim(),\n                name: actionParts[2].trim(),\n                args: actionParts.slice(3).map(arg => arg.trim()),\n              };\n            }\n          }\n\n          const dialogData = {\n            type: 'dialogue',\n            character: dialogueMatch[1].trim() || '旁白',\n            position: dialogueMatch[2].trim().toUpperCase() || null,\n            sprite: spriteImg,\n            text: text,\n            inlineAction: inlineAction,\n            original: line,\n          };\n\n          tempScenes.push(dialogData);\n\n          currentExecutableIndex++;\n          return;\n        }\n\n        tempScenes.push({\n          type: 'unknown',\n          original: line,\n        });\n        currentExecutableIndex++;\n      });\n\n      if (config.defaultBackground) {\n        tempScenes.unshift({\n          type: 'command',\n          command: 'bg',\n          args: [config.defaultBackground],\n          original: `[bg|${config.defaultBackground}]`,\n        });\n      }\n\n      gameData.scenes = tempScenes;\n      return gameData;\n    } catch (error) {\n      return { scenes: [], currentSceneIndex: 0 };\n    }\n  }\n\n  function isValidUrl(url) {\n    return !!url;\n  }\n\n  function createGameHTML(messageId, gameData) {\n    const container = $('<div class=\"roleplay_galgame\"></div>');\n\n    container.append(`\n      <style>\n        @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css');\n        \n        /* 基本容器样式 */\n        .galgame-container-${messageId} {\n          width: 360px;\n          position: relative;\n          background-color: #000;\n          background-size: cover;\n          background-position: center;\n          border-radius: 12px;\n          overflow: hidden;\n          box-shadow: 0 5px 15px rgba(0,0,0,0.2);\n          margin: 15px auto;\n          display: flex;\n          flex-direction: column;\n          user-select: none;\n          -webkit-user-select: none;\n          -moz-user-select: none;\n          -ms-user-select: none;\n          pointer-events: auto;\n          aspect-ratio: 16/9;\n          height: auto;\n          width: 100%;\n        }\n        \n        /* PC端适配 */\n        @media (min-width: 768px) {\n          .galgame-container-${messageId} {\n            max-width: 90%;\n            aspect-ratio: 16/9;\n          }\n        }\n        \n        /* 移动端适配 */\n        @media (max-width: 767px) {\n          .galgame-container-${messageId} {\n            max-width: 100%;\n            aspect-ratio: 3/5;\n          }\n        }\n        \n        /* 背景层 */\n        .galgame-bg-${messageId} {\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 100%;\n          height: 100%;\n          background-size: cover;\n          background-position: center;\n          z-index: 0;\n          pointer-events: none;\n        }\n        \n        /* 角色区域 */\n        .galgame-char-area-${messageId} {\n          flex: 1;\n          display: flex;\n          justify-content: center;\n          align-items: flex-end;\n          position: relative;\n          min-height: 70%;\n          z-index: 1;\n        }\n        \n        /* 移动端角色区域调整 */\n        @media (max-width: 767px) {\n          .galgame-char-area-${messageId} {\n            min-height: calc(100% - ${config.mobileDiaogueHeight}% - 20px);\n          }\n        }\n        \n        /* 角色立绘 */\n        .galgame-char-${messageId} {\n          max-width: 100%;\n          max-height: 120%;\n          position: absolute;\n          bottom: ${config.characterBottomOffset}%;\n          opacity: 0;\n          transition: opacity 0.3s ease-in-out, filter 0.3s ease-in-out;\n          pointer-events: none;\n        }\n        \n        .galgame-char-${messageId}.left {\n          left: 0;\n          transform: scaleX(1);\n        }\n        \n        .galgame-char-${messageId}.center {\n          left: 50%;\n          transform: translateX(-50%);\n        }\n        \n        .galgame-char-${messageId}.right {\n          right: 0;\n          transform: scaleX(-1);\n        }\n        \n        .galgame-char-${messageId}.active {\n          opacity: 1;\n        }\n        \n        .galgame-char-${messageId}.active.dimmed {\n          filter: brightness(0.5) grayscale(0.3);\n        }\n        \n        /* CG图片 */\n        .galgame-cg-${messageId} {\n          position: absolute;\n          top: 0;\n          left: 5%;\n          width: 90%;\n          height: 70%;\n          z-index: 3;\n          opacity: 0;\n          pointer-events: none;\n          transition: opacity 0.3s ease-in-out;\n          border: 6px solid white;\n          border-radius: 8px;\n          box-shadow: 0 2px 8px rgba(0,0,0,0.2);\n          background-color: white;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          overflow: hidden;\n        }\n        \n        .galgame-cg-${messageId} img {\n          max-width: 100%;\n          max-height: 100%;\n          object-fit: contain;\n        }\n        \n        .galgame-cg-${messageId}.active {\n          opacity: 1;\n        }\n        \n        /* 对话框 */\n        .galgame-dialogue-${messageId} {\n          background-color: rgba(255, 255, 255, 0.8);\n          backdrop-filter: blur(3px);\n          border-radius: 10px;\n          padding: 25px 18px 15px 18px;\n          margin: 10px;\n          box-shadow: 0 2px 10px rgba(0,0,0,0.15);\n          position: relative;\n          min-height: 80px;\n          z-index: 4;\n          height: ${config.dialogueHeight}%;\n          user-select: none;\n        }\n        \n        /* 移动端对话框高度调整 */\n        @media (max-width: 767px) {\n          .galgame-dialogue-${messageId} {\n            height: ${config.mobileDiaogueHeight}%;\n            min-height: 120px;\n          }\n        }\n        \n        /* 角色名称 */\n        .galgame-name-${messageId} {\n          position: absolute;\n          top: -20px;\n          left: 15px;\n          background-color: #ffacb6;\n          color: white;\n          padding: 4px 14px;\n          border-radius: 15px;\n          font-weight: bold;\n          box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n          font-size: 16px;\n          z-index: 5;\n          user-select: none;\n        }\n        \n        /* 对话文本 */\n        .galgame-text-${messageId} {\n          margin-top: 0;\n          color: #333;\n          font-size: 17px;\n          line-height: 1.5;\n          user-select: none;\n        }\n        \n        /* 下一步指示器 */\n        .galgame-next-${messageId} {\n          position: absolute;\n          bottom: 5px;\n          right: 15px;\n          font-size: 20px;\n          color: #ff69b4;\n          animation: pointer-pulse-${messageId} 1.5s infinite;\n          user-select: none;\n        }\n        \n        @keyframes pointer-pulse-${messageId} {\n          0% { transform: scale(1); opacity: 0.7; }\n          50% { transform: scale(1.1); opacity: 1; }\n          100% { transform: scale(1); opacity: 0.7; }\n        }\n        \n        /* 选项区域 */\n        .galgame-choices-${messageId} {\n          display: flex;\n          flex-direction: column;\n          gap: 8px;\n          padding: 10px;\n          position: absolute;\n          top: 50%;\n          left: 50%;\n          transform: translate(-50%, -50%);\n          width: 80%;\n          max-width: 300px;\n          z-index: 6;\n          user-select: none;\n        }\n        \n        /* 选项按钮 */\n        .galgame-choice-${messageId} {\n          background-color: rgba(255, 255, 255, 0.8);\n          border: 1px solid #ccc;\n          border-radius: 8px;\n          padding: 10px 15px;\n          cursor: pointer;\n          transition: all 0.2s;\n          color: #333;\n          font-weight: bold;\n          text-align: center;\n          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n          user-select: none;\n        }\n        \n        .galgame-choice-${messageId}:hover {\n          background-color: rgba(240, 240, 240, 0.9);\n          transform: translateY(-2px);\n        }\n        \n        /* 遮罩层 */\n        .galgame-overlay-${messageId} {\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 100%;\n          height: 100%;\n          background: black;\n          opacity: 0;\n          transition: opacity 0.5s;\n          pointer-events: none;\n          z-index: 7;\n        }\n        \n        /* 履历按钮 */\n        .galgame-history-btn-${messageId} {\n          position: absolute;\n          top: 10px;\n          right: 10px;\n          background-color: rgba(255, 255, 255, 0.8);\n          color: #333;\n          border: 1px solid #ddd;\n          border-radius: 8px;\n          padding: 6px 12px;\n          font-size: 14px;\n          font-weight: bold;\n          cursor: pointer;\n          z-index: 10;\n          box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n          transition: background-color 0.2s;\n        }\n        \n        .galgame-history-btn-${messageId}:hover {\n          background-color: rgba(240, 240, 240, 0.9);\n        }\n        \n        /* 履历模态框 */\n        .galgame-history-modal-${messageId} {\n          display: none;\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 100%;\n          height: 100%;\n          background-color: rgba(0, 0, 0, 0.7);\n          z-index: 20;\n        }\n        \n        .galgame-history-content-${messageId} {\n          position: absolute;\n          top: 50%;\n          left: 50%;\n          transform: translate(-50%, -50%);\n          width: 90%;\n          height: 80%;\n          background-color: rgba(255, 255, 255, 0.8);\n          border-radius: 12px;\n          padding: 20px;\n          overflow-y: auto;\n          max-height: 100%;\n          box-shadow: 0 5px 15px rgba(0,0,0,0.3);\n        }\n        \n        .galgame-history-title-${messageId} {\n          text-align: center;\n          margin-bottom: 15px;\n          padding-bottom: 10px;\n          border-bottom: 1px solid #ddd;\n          color: #333;\n          font-weight: bold;\n        }\n        \n        .galgame-history-list-${messageId} {\n          display: flex;\n          flex-direction: column;\n          gap: 10px;\n        }\n        \n        .galgame-history-item-${messageId} {\n          padding: 10px;\n          border-radius: 8px;\n          background-color: rgba(240, 240, 240, 0.8);\n        }\n        \n        .galgame-history-speaker-${messageId} {\n          font-weight: bold;\n          color: #ff7eb3;\n          margin-bottom: 5px;\n        }\n        \n        .galgame-history-text-${messageId} {\n          color: #000000;\n        }\n        \n        .galgame-history-close-${messageId} {\n          position: absolute;\n          top: 10px;\n          right: 10px;\n          background: none;\n          border: none;\n          font-size: 20px;\n          cursor: pointer;\n          color: #333;\n        }\n        \n        /* 晃动动画 */\n        .galgame-history-shake-${messageId} {\n          animation: shake-light-${messageId} 0.5s ease-in-out;\n        }\n        \n        @keyframes shake-light-${messageId} {\n          0%, 100% { transform: translateX(0) scaleX(var(--originalScaleX, 1)); }\n          10%, 30%, 50%, 70%, 90% { transform: translateX(-5px) scaleX(var(--originalScaleX, 1)); }\n          20%, 40%, 60%, 80% { transform: translateX(5px) scaleX(var(--originalScaleX, 1)); }\n        }\n        \n        .shake-center-${messageId} {\n          animation: shake-center-${messageId} 0.5s ease-in-out;\n        }\n        \n        @keyframes shake-center-${messageId} {\n          0%, 100% { transform: translateX(-50%) scaleX(var(--originalScaleX, 1)); }\n          10%, 30%, 50%, 70%, 90% { transform: translateX(calc(-50% - 5px)) scaleX(var(--originalScaleX, 1)); }\n          20%, 40%, 60%, 80% { transform: translateX(calc(-50% + 5px)) scaleX(var(--originalScaleX, 1)); }\n        }\n        \n        /* 统一图标颜色 */\n        .galgame-container-${messageId} .fas {\n          color: #ff69b4;\n        }\n        \n        /* 保持履历按钮文字颜色不变 */\n        .galgame-history-btn-${messageId} {\n          color: #333;\n        }\n      </style>\n    `);\n\n    const gameContainer = $(`<div class=\"galgame-container-${messageId}\"></div>`);\n\n    const bgLayer = $(`<div class=\"galgame-bg-${messageId}\" id=\"bg-${messageId}\"></div>`);\n    gameContainer.append(bgLayer);\n\n    const charArea = $(`<div class=\"galgame-char-area-${messageId}\"></div>`);\n    charArea.append(\n      `<img class=\"galgame-char-${messageId} left\" id=\"char-left-${messageId}\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\" alt=\"\">`,\n    );\n    charArea.append(\n      `<img class=\"galgame-char-${messageId} center\" id=\"char-center-${messageId}\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\" alt=\"\">`,\n    );\n    charArea.append(\n      `<img class=\"galgame-char-${messageId} right\" id=\"char-right-${messageId}\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\" alt=\"\">`,\n    );\n    gameContainer.append(charArea);\n\n    const cgLayer = $(\n      `<div class=\"galgame-cg-${messageId}\" id=\"cg-${messageId}\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\" alt=\"\"></div>`,\n    );\n    gameContainer.append(cgLayer);\n\n    const historyBtn = $(\n      `<button class=\"galgame-history-btn-${messageId}\" id=\"history-btn-${messageId}\"><i class=\"fas fa-history\"></i> 履历</button>`,\n    );\n    gameContainer.append(historyBtn);\n\n    const historyModal = $(`\n      <div class=\"galgame-history-modal-${messageId}\" id=\"history-modal-${messageId}\">\n        <div class=\"galgame-history-content-${messageId}\">\n          <button class=\"galgame-history-close-${messageId}\" id=\"history-close-${messageId}\"><i class=\"fas fa-times\"></i></button>\n          <div class=\"galgame-history-title-${messageId}\">对话履历</div>\n          <div class=\"galgame-history-list-${messageId}\" id=\"history-list-${messageId}\"></div>\n        </div>\n      </div>\n    `);\n    gameContainer.append(historyModal);\n\n    const dialogueBox = $(`<div class=\"galgame-dialogue-${messageId}\"></div>`);\n    dialogueBox.append(`<div class=\"galgame-name-${messageId}\" id=\"name-${messageId}\"></div>`);\n    dialogueBox.append(`<div class=\"galgame-text-${messageId}\" id=\"text-${messageId}\"></div>`);\n    dialogueBox.append(\n      `<div class=\"galgame-next-${messageId}\" id=\"next-${messageId}\"><i class=\"fas fa-caret-down\"></i></div>`,\n    );\n\n    const choicesArea = $(`<div class=\"galgame-choices-${messageId}\" id=\"choices-${messageId}\"></div>`);\n\n    const overlay = $(`<div class=\"galgame-overlay-${messageId}\" id=\"overlay-${messageId}\"></div>`);\n\n    gameContainer.append(bgLayer);\n    gameContainer.append(charArea);\n    gameContainer.append(cgLayer);\n    gameContainer.append(dialogueBox);\n    gameContainer.append(choicesArea);\n    gameContainer.append(overlay);\n\n    container.append(gameContainer);\n\n    gameStates[messageId] = {\n      data: gameData,\n      currentIndex: 0,\n      waitingForClick: true,\n      characters: {\n        L: { name: null, sprite: null },\n        C: { name: null, sprite: null },\n        R: { name: null, sprite: null },\n      },\n    };\n\n    log('游戏HTML创建完成:', messageId);\n    return container;\n  }\n\n  function setupGameEvents(messageId, gameData) {\n    const container = $(`.galgame-container-${messageId}`);\n    if (!container.length) return;\n\n    container.on('click', function (e) {\n      e.stopPropagation();\n      const state = gameStates[messageId];\n\n      if (!state || state.processing) return;\n\n      if (state.showingChoices) return;\n\n      processNextScene(messageId);\n    });\n\n    $(`#history-btn-${messageId}`).on('click', function (e) {\n      e.stopPropagation();\n      showHistoryModal(messageId);\n    });\n\n    $(`#history-close-${messageId}`).on('click', function (e) {\n      e.stopPropagation();\n      hideHistoryModal(messageId);\n    });\n\n    setTimeout(() => {\n      processNextScene(messageId);\n    }, 100);\n  }\n\n  function processNextScene(messageId) {\n    const state = gameStates[messageId];\n    if (!state) return;\n\n    if (window.GALGAME_FINISHING_STREAM || window.GALGAME_EDITING_MESSAGE) {\n      return;\n    }\n\n    state.processing = true;\n\n    const scene = state.data.scenes[state.currentIndex];\n    if (!scene) {\n      $(`#text-${messageId}`).text('对话已结束');\n      $(`#next-${messageId}`).hide();\n\n      const replayButton = $(\n        `<button style=\"position:absolute; bottom:5px; left:15px; padding:5px 15px; background-color:#ff69b4; color:white; border:none; border-radius:5px; cursor:pointer;\"><i class=\"fas fa-redo-alt\"></i> 重新播放</button>`,\n      );\n      replayButton.on('click', function (e) {\n        e.stopPropagation();\n        state.currentIndex = 0;\n        $(`#text-${messageId}`).text('');\n        $(this).remove();\n\n        hideAllCharacters(messageId);\n\n        state.characters = {\n          L: { name: null, sprite: null },\n          C: { name: null, sprite: null },\n          R: { name: null, sprite: null },\n        };\n\n        hideCG(messageId);\n\n        $(`#bg-${messageId}`).css({\n          'background-image': 'none',\n          'background-color': '#000',\n        });\n\n        $(`#name-${messageId}`).hide();\n\n        $(`#overlay-${messageId}`).css({\n          opacity: '0',\n          transition: 'none',\n        });\n\n        $(`#next-${messageId}`).show();\n\n        processNextScene(messageId);\n      });\n\n      $(`.galgame-dialogue-${messageId}`).append(replayButton);\n\n      state.processing = false;\n      return;\n    }\n\n    try {\n      if (scene.type === 'dialogue') {\n        const nameElement = $(`#name-${messageId}`);\n        if (scene.character === '旁白') {\n          nameElement.hide();\n          // 对于旁白对话，不应该亮起任何角色，但也不要额外暗化\n        } else {\n          nameElement.text(scene.character).show();\n          \n          // 设置角色立绘\n          if (scene.position && scene.sprite) {\n            showCharacter(messageId, scene.character, scene.position, scene.sprite);\n          } else {\n            // 如果只有角色名没有立绘和位置，尝试找到该角色并点亮\n            for (const p in state.characters) {\n              if (state.characters[p].name === scene.character) {\n                const pos = p === 'L' ? 'left' : p === 'C' ? 'center' : 'right';\n                const element = $(`#char-${pos}-${messageId}`);\n                element.removeClass('dimmed').addClass('active');\n                \n                // 使其他角色变暗\n                for (const otherP in state.characters) {\n                  if (otherP !== p && state.characters[otherP].name) {\n                    const otherPos = otherP === 'L' ? 'left' : otherP === 'C' ? 'center' : 'right';\n                    $(`#char-${otherPos}-${messageId}`).addClass('dimmed');\n                  }\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        typewriterEffect(messageId, scene.text, () => {\n          if (scene.inlineAction) {\n            executeAction(messageId, scene.inlineAction.target, scene.inlineAction.name, scene.inlineAction.args);\n          }\n\n          state.currentIndex++;\n          state.processing = false;\n          $(`#next-${messageId}`).show();\n        });\n      } else if (scene.type === 'command') {\n        processCommand(messageId, scene.command, scene.args).then(() => {\n          state.currentIndex++;\n          state.processing = false;\n\n          if (scene.command !== 'choice' && scene.command !== 'wait') {\n            setTimeout(() => {\n              processNextScene(messageId);\n            }, 50);\n          }\n        });\n      } else {\n        state.currentIndex++;\n        state.processing = false;\n        processNextScene(messageId);\n      }\n    } catch (error) {\n      state.currentIndex++;\n      state.processing = false;\n    }\n  }\n\n  async function processCommand(messageId, command, args) {\n    const state = gameStates[messageId];\n    if (!state) return;\n\n    try {\n      switch (command) {\n        case 'bg':\n          await setBackground(messageId, args[0], args[1], args[2] ? parseFloat(args[2]) : 0.5);\n          break;\n\n        case 'show':\n          showCharacter(messageId, args[0], args[1].toUpperCase(), args[2]);\n          break;\n\n        case 'hide':\n          hideCharacter(messageId, args[0]);\n          break;\n\n        case 'hide_all':\n          hideAllCharacters(messageId);\n          break;\n\n        case 'cg':\n          showCG(messageId, args[0]);\n          break;\n\n        case 'hide_cg':\n          hideCG(messageId);\n          break;\n\n        case 'action':\n          executeAction(messageId, args[0], args[1], args.slice(2));\n          break;\n\n        case 'wait':\n          const waitTime = parseFloat(args[0]) * 1000 || 500;\n          $(`#next-${messageId}`).hide();\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n          $(`#next-${messageId}`).show();\n          break;\n\n        case 'choice':\n          state.showingChoices = true;\n          $(`#next-${messageId}`).hide();\n\n          const choicesContainer = $(`#choices-${messageId}`);\n          choicesContainer.empty();\n\n          const choiceOverlay = $(\n            `<div style=\"position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:4;\"></div>`,\n          );\n          $(`.galgame-container-${messageId}`).append(choiceOverlay);\n\n          args.forEach((choice, index) => {\n            let text = choice.trim();\n            const tagIndex = text.indexOf('>');\n            if (tagIndex !== -1) {\n              text = text.substring(0, tagIndex).trim();\n            }\n\n            const choiceElement = $(`<div class=\"galgame-choice-${messageId}\">${text}</div>`);\n            choiceElement.on('click', function (e) {\n              e.stopPropagation();\n\n              choicesContainer.empty();\n              choiceOverlay.remove();\n              state.showingChoices = false;\n\n              if (typeof triggerSlash === 'function') {\n                triggerSlash(`/setinput ${text}`);\n              }\n\n              state.currentIndex++;\n              processNextScene(messageId);\n            });\n\n            choicesContainer.append(choiceElement);\n          });\n          break;\n\n        case 'effect':\n          const effectType = args[0];\n          const effectParams = args.slice(1);\n\n          if (effectType === 'screen_flash') {\n            const overlay = $(`#overlay-${messageId}`);\n            overlay.css({\n              opacity: '0.8',\n              background: 'white',\n              transition: 'opacity 0.1s',\n            });\n\n            await new Promise(resolve => setTimeout(resolve, 100));\n\n            overlay.css({\n              opacity: '0',\n              transition: 'opacity 0.1s',\n            });\n\n            await new Promise(resolve => setTimeout(resolve, 100));\n          } else if (effectType === 'fade_to_black') {\n            const overlay = $(`#overlay-${messageId}`);\n            const duration = effectParams[0] ? parseFloat(effectParams[0]) : 0.5;\n            overlay.css({\n              opacity: '0',\n              background: 'black',\n              transition: `opacity ${duration}s`,\n            });\n\n            await new Promise(resolve => setTimeout(resolve, 10));\n\n            overlay.css('opacity', '1');\n\n            await new Promise(resolve => setTimeout(resolve, duration * 1000));\n          } else if (effectType === 'fade_from_black') {\n            const overlay = $(`#overlay-${messageId}`);\n            const duration = effectParams[0] ? parseFloat(effectParams[0]) : 0.5;\n            overlay.css({\n              opacity: '1',\n              background: 'black',\n              transition: `opacity ${duration}s`,\n            });\n\n            await new Promise(resolve => setTimeout(resolve, 10));\n\n            overlay.css('opacity', '0');\n\n            await new Promise(resolve => setTimeout(resolve, duration * 1000));\n          }\n          break;\n      }\n    } catch (error) {\n      log(`处理命令出错: ${command}`, error);\n    }\n  }\n\n  function showCharacter(messageId, name, position, spriteUrl) {\n    const state = gameStates[messageId];\n    if (!state) return;\n\n    if (!['L', 'C', 'R'].includes(position)) {\n      return;\n    }\n\n    try {\n      const pos = position === 'L' ? 'left' : position === 'C' ? 'center' : 'right';\n      const charElement = $(`#char-${pos}-${messageId}`);\n\n      if (!charElement.length) {\n        return;\n      }\n\n      // 确保当前角色不被暗化\n      charElement.removeClass('dimmed');\n\n      for (const p in state.characters) {\n        if (p !== position && state.characters[p].name === name) {\n          const otherPos = p === 'L' ? 'left' : p === 'C' ? 'center' : 'right';\n          $(`#char-${otherPos}-${messageId}`).removeClass('active');\n          state.characters[p].name = null;\n          state.characters[p].sprite = null;\n        }\n      }\n\n      let actualSpriteUrl = '';\n      let imageType = 'char';\n\n      if (spriteUrl && typeof spriteUrl === 'string') {\n        const tagRegexes = {\n          char: /\\[char\\|([^\\]]+)\\]/,\n          bg: /\\[bg\\|([^\\]]+)\\]/,\n          cg: /\\[cg\\|([^\\]]+)\\]/,\n        };\n\n        let alias = null;\n\n        for (const type in tagRegexes) {\n          const match = spriteUrl.match(tagRegexes[type]);\n          if (match) {\n            alias = match[1].trim();\n            imageType = type;\n            break;\n          }\n        }\n\n        if (alias) {\n          const aliasObj = imageAliasManager.getAliases ? imageAliasManager.getAliases() : {};\n          if (aliasObj && alias in aliasObj) {\n            actualSpriteUrl = aliasObj[alias];\n          }\n        } else {\n          const aliasObj = imageAliasManager.getAliases ? imageAliasManager.getAliases() : {};\n          if (aliasObj && spriteUrl in aliasObj) {\n            actualSpriteUrl = aliasObj[spriteUrl];\n          } else if (spriteUrl.startsWith('http://') || spriteUrl.startsWith('https://')) {\n            actualSpriteUrl = spriteUrl;\n          }\n        }\n      }\n\n      if (!actualSpriteUrl || !actualSpriteUrl.startsWith('http')) {\n        charElement.attr(\n          'src',\n          'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=',\n        );\n        charElement.attr('alt', name + ' (图片未设置)');\n        charElement.css('display', 'block');\n        charElement.addClass('active');\n\n        state.characters[position] = {\n          name: name,\n          sprite: null,\n        };\n\n        // 使其他角色变暗\n        for (const p in state.characters) {\n          if (p !== position && state.characters[p].name) {\n            const otherPos = p === 'L' ? 'left' : p === 'C' ? 'center' : 'right';\n            $(`#char-${otherPos}-${messageId}`).addClass('dimmed');\n          }\n        }\n\n        return;\n      }\n\n      const img = new Image();\n      img.crossOrigin = 'anonymous';\n\n      img.onload = function () {\n        charElement.attr('src', actualSpriteUrl);\n        charElement.attr('alt', name);\n        charElement.css('display', 'block');\n\n        if (imageType === 'char') {\n          charElement.css({\n            'max-height': '120%',\n            'max-width': '100%',\n            bottom: `${config.characterBottomOffset}%`,\n          });\n        }\n\n        charElement.addClass('active');\n\n        state.characters[position] = {\n          name: name,\n          sprite: actualSpriteUrl,\n        };\n\n        // 使其他角色变暗\n        for (const p in state.characters) {\n          if (p !== position && state.characters[p].name) {\n            const otherPos = p === 'L' ? 'left' : p === 'C' ? 'center' : 'right';\n            $(`#char-${otherPos}-${messageId}`).addClass('dimmed');\n          }\n        }\n      };\n\n      img.onerror = function () {\n        charElement.attr(\n          'src',\n          'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=',\n        );\n        charElement.attr('alt', name + ' (图片加载失败)');\n        charElement.css('display', 'block');\n        charElement.addClass('active');\n\n        state.characters[position] = {\n          name: name,\n          sprite: null,\n        };\n\n        // 使其他角色变暗\n        for (const p in state.characters) {\n          if (p !== position && state.characters[p].name) {\n            const otherPos = p === 'L' ? 'left' : p === 'C' ? 'center' : 'right';\n            $(`#char-${otherPos}-${messageId}`).addClass('dimmed');\n          }\n        }\n      };\n\n      img.src = actualSpriteUrl;\n    } catch (error) {}\n  }\n\n  function hideCharacter(messageId, target) {\n    const state = gameStates[messageId];\n    if (!state) return;\n\n    try {\n      if (['L', 'C', 'R'].includes(target)) {\n        const pos = target === 'L' ? 'left' : target === 'C' ? 'center' : 'right';\n        const charElement = $(`#char-${pos}-${messageId}`);\n\n        if (charElement.length) {\n          charElement.removeClass('active dimmed');\n          state.characters[target] = { name: null, sprite: null };\n        }\n      } else {\n        for (const p in state.characters) {\n          if (state.characters[p] && state.characters[p].name === target) {\n            const pos = p === 'L' ? 'left' : p === 'C' ? 'center' : 'right';\n            const charElement = $(`#char-${pos}-${messageId}`);\n\n            if (charElement.length) {\n              charElement.removeClass('active dimmed');\n              state.characters[p] = { name: null, sprite: null };\n            }\n          }\n        }\n      }\n    } catch (error) {}\n  }\n\n  function hideAllCharacters(messageId) {\n    $(`#char-left-${messageId}, #char-center-${messageId}, #char-right-${messageId}`).removeClass('active dimmed');\n\n    const state = gameStates[messageId];\n    if (state) {\n      state.characters.L = { name: null, sprite: null };\n      state.characters.C = { name: null, sprite: null };\n      state.characters.R = { name: null, sprite: null };\n    }\n  }\n\n  function executeAction(messageId, targetName, actionType, params) {\n    try {\n      const state = gameStates[messageId];\n      if (!state) return;\n\n      let targetElement = null;\n      let pos = null;\n\n      for (const p in state.characters) {\n        if (state.characters[p].name === targetName) {\n          pos = p === 'L' ? 'left' : p === 'C' ? 'center' : 'right';\n          targetElement = $(`#char-${pos}-${messageId}`);\n          break;\n        }\n      }\n\n      if (!targetElement || !targetElement.length) {\n        return;\n      }\n\n      if (actionType === 'shake') {\n        const intensity = params[0] || 'light';\n\n        let originalScaleX = 1;\n        if (pos === 'right') {\n          originalScaleX = -1;\n        }\n\n        targetElement.css('--originalScaleX', originalScaleX);\n\n        // 为所有位置的角色使用通用的晃动逻辑\n        if (pos === 'center') {\n          targetElement.removeClass(`shake-light-${messageId} shake-center-${messageId}`);\n          void targetElement[0].offsetWidth; // 强制重排\n          targetElement.addClass(`shake-center-${messageId}`);\n\n          setTimeout(() => {\n            targetElement.removeClass(`shake-center-${messageId}`);\n            targetElement.css('transform', 'translateX(-50%)');\n          }, 500);\n        } else if (pos === 'left') {\n          // 左侧角色特定处理\n          targetElement.removeClass(`shake-light-${messageId} shake-center-${messageId}`);\n          void targetElement[0].offsetWidth; // 强制重排\n          \n          // 保存原始样式以便还原\n          const originalTransition = targetElement.css('transition');\n          targetElement.css('transition', 'none');\n          \n          // 添加自定义动画\n          targetElement.css('animation', `shake-light-${messageId} 0.5s ease-in-out`);\n          \n          setTimeout(() => {\n            targetElement.css('animation', '');\n            targetElement.css('transition', originalTransition);\n            targetElement.css('transform', 'scaleX(1)');\n          }, 500);\n        } else if (pos === 'right') {\n          // 右侧角色特定处理\n          targetElement.removeClass(`shake-light-${messageId} shake-center-${messageId}`);\n          void targetElement[0].offsetWidth; // 强制重排\n          \n          // 保存原始样式以便还原\n          const originalTransition = targetElement.css('transition');\n          targetElement.css('transition', 'none');\n          \n          // 添加自定义动画\n          targetElement.css('animation', `shake-light-${messageId} 0.5s ease-in-out`);\n          \n          setTimeout(() => {\n            targetElement.css('animation', '');\n            targetElement.css('transition', originalTransition);\n            targetElement.css('transform', 'scaleX(-1)');\n          }, 500);\n        }\n      } else if (actionType === 'jump_up') {\n        targetElement.css('transition', 'transform 0.15s ease-out');\n\n        if (pos === 'center') {\n          targetElement.css('transform', 'translateX(-50%) translateY(-20px)');\n\n          setTimeout(() => {\n            targetElement.css('transition', 'transform 0.15s ease-in');\n            targetElement.css('transform', 'translateX(-50%)');\n          }, 150);\n        } else {\n          targetElement.css('transform', 'translateY(-20px) ' + (pos === 'right' ? 'scaleX(-1)' : 'scaleX(1)'));\n\n          setTimeout(() => {\n            targetElement.css('transition', 'transform 0.15s ease-in');\n            targetElement.css('transform', pos === 'right' ? 'scaleX(-1)' : 'scaleX(1)');\n          }, 150);\n        }\n      } else if (actionType === 'jump_down') {\n        targetElement.css('transition', 'transform 0.15s ease-out');\n\n        if (pos === 'center') {\n          targetElement.css('transform', 'translateX(-50%) translateY(10px)');\n\n          setTimeout(() => {\n            targetElement.css('transition', 'transform 0.15s ease-in');\n            targetElement.css('transform', 'translateX(-50%)');\n          }, 150);\n        } else {\n          targetElement.css('transform', 'translateY(10px) ' + (pos === 'right' ? 'scaleX(-1)' : 'scaleX(1)'));\n\n          setTimeout(() => {\n            targetElement.css('transition', 'transform 0.15s ease-in');\n            targetElement.css('transform', pos === 'right' ? 'scaleX(-1)' : 'scaleX(1)');\n          }, 150);\n        }\n      }\n    } catch (error) {\n      log('执行动作时出错:', error);\n    }\n  }\n\n  function typewriterEffect(messageId, text, onComplete) {\n    const textElement = $(`#text-${messageId}`);\n    const nextIndicator = $(`#next-${messageId}`);\n\n    nextIndicator.hide();\n    textElement.text('');\n\n    if (!text || text.length === 0) {\n      nextIndicator.show();\n      if (onComplete) onComplete();\n      return;\n    }\n\n    safeExecute(\n      async () => {\n        let i = 0;\n        const speed = config.typewriterSpeed;\n\n        function type() {\n          if (i < text.length) {\n            textElement.text(textElement.text() + text.charAt(i));\n            i++;\n            setTimeout(type, speed);\n          } else {\n            nextIndicator.show();\n\n            addToHistory(messageId, $(`#name-${messageId}`).text(), text);\n\n            if (onComplete) onComplete();\n          }\n        }\n\n        type();\n      },\n      null,\n      '文本打字机效果出错',\n    ).then(() => {\n      // 确保回调被执行\n      if (!textElement.text()) {\n        textElement.text(text);\n        nextIndicator.show();\n        if (onComplete) onComplete();\n      }\n    });\n  }\n\n  function addToHistory(messageId, speaker, text) {\n    const state = gameStates[messageId];\n    if (!state) return;\n\n    if (!state.history) {\n      state.history = [];\n    }\n\n    state.history.push({\n      speaker: speaker || '旁白',\n      text: text,\n    });\n\n    if (state.history.length > 100) {\n      state.history.shift();\n    }\n  }\n\n  function showHistoryModal(messageId) {\n    const state = gameStates[messageId];\n    if (!state || !state.history) return;\n\n    const historyList = $(`#history-list-${messageId}`);\n    historyList.empty();\n\n    for (let i = 0; i < state.history.length; i++) {\n      const item = state.history[i];\n      const itemElement = $(`\n        <div class=\"galgame-history-item-${messageId}\">\n          <div class=\"galgame-history-speaker-${messageId}\">${item.speaker}</div>\n          <div class=\"galgame-history-text-${messageId}\">${item.text}</div>\n        </div>\n      `);\n      historyList.append(itemElement);\n    }\n\n    $(`#history-modal-${messageId}`).css('display', 'block');\n\n    const historyContent = $(`.galgame-history-content-${messageId}`);\n    historyContent.scrollTop(historyContent[0].scrollHeight);\n  }\n\n  function hideHistoryModal(messageId) {\n    $(`#history-modal-${messageId}`).css('display', 'none');\n  }\n\n  function showCG(messageId, cgUrl) {\n    const cgElement = $(`#cg-${messageId}`);\n    if (!cgElement.length) return;\n\n    try {\n      let actualCgUrl = '';\n\n      if (cgUrl && typeof cgUrl === 'string') {\n        const cgTagRegex = /\\[cg\\|([^\\]]+)\\]/;\n        const match = cgUrl.match(cgTagRegex);\n\n        if (match) {\n          const alias = match[1].trim();\n\n          const aliasObj = imageAliasManager.getAliases ? imageAliasManager.getAliases() : {};\n          if (aliasObj && alias in aliasObj) {\n            actualCgUrl = aliasObj[alias];\n          }\n        } else {\n          const aliasObj = imageAliasManager.getAliases ? imageAliasManager.getAliases() : {};\n          if (aliasObj && cgUrl in aliasObj) {\n            actualCgUrl = aliasObj[cgUrl];\n          } else if (cgUrl.startsWith('http://') || cgUrl.startsWith('https://')) {\n            actualCgUrl = cgUrl;\n          }\n        }\n      }\n\n      if (!actualCgUrl || !actualCgUrl.startsWith('http')) {\n        cgElement.removeClass('active');\n        return;\n      }\n\n      const img = new Image();\n      img.crossOrigin = 'anonymous';\n\n      img.onload = function () {\n        cgElement.find('img').attr('src', actualCgUrl);\n        cgElement.addClass('active');\n      };\n\n      img.onerror = function () {\n        cgElement.removeClass('active');\n      };\n\n      img.src = actualCgUrl;\n    } catch (error) {\n      cgElement.removeClass('active');\n    }\n  }\n\n  function hideCG(messageId) {\n    const cgElement = $(`#cg-${messageId}`);\n    if (cgElement.length) {\n      cgElement.removeClass('active');\n    }\n  }\n\n  async function setBackground(messageId, bgUrl, transitionType, duration) {\n    const container = $(`.galgame-container-${messageId}`);\n    const bgElement = $(`#bg-${messageId}`);\n\n    if (!container.length || !bgElement.length) return;\n\n    try {\n      let actualBgUrl = '';\n      let imageType = 'bg';\n\n      if (bgUrl && typeof bgUrl === 'string') {\n        const tagRegexes = {\n          bg: /\\[bg\\|([^\\]]+)\\]/,\n        };\n\n        let alias = null;\n\n        for (const type in tagRegexes) {\n          const match = bgUrl.match(tagRegexes[type]);\n          if (match) {\n            alias = match[1].trim();\n            imageType = type;\n            break;\n          }\n        }\n\n        if (alias) {\n          const aliasObj = imageAliasManager.getAliases ? imageAliasManager.getAliases() : {};\n          if (aliasObj && alias in aliasObj) {\n            actualBgUrl = aliasObj[alias];\n          }\n        } else {\n          const aliasObj = imageAliasManager.getAliases ? imageAliasManager.getAliases() : {};\n          if (aliasObj && bgUrl in aliasObj) {\n            actualBgUrl = aliasObj[bgUrl];\n          } else if (bgUrl.startsWith('http://') || bgUrl.startsWith('https://')) {\n            actualBgUrl = bgUrl;\n          }\n        }\n      }\n\n      if (!actualBgUrl || !actualBgUrl.startsWith('http')) {\n        bgElement.css({\n          'background-image': 'none',\n          'background-color': '#000',\n        });\n        return;\n      }\n\n      if (transitionType === 'fade') {\n        const overlay = $(`#overlay-${messageId}`);\n        const transitionDuration = duration || 0.5;\n\n        overlay.css({\n          opacity: '0',\n          background: '#000',\n          transition: `opacity ${transitionDuration}s`,\n        });\n\n        await new Promise(resolve => setTimeout(resolve, 10));\n\n        overlay.css('opacity', '1');\n\n        await new Promise(resolve => setTimeout(resolve, transitionDuration * 1000));\n\n        bgElement.css({\n          'background-image': `url(${actualBgUrl})`,\n          'background-size': 'cover',\n          'background-position': 'center',\n        });\n\n        await new Promise(resolve => setTimeout(resolve, 50));\n\n        overlay.css({\n          opacity: '0',\n          transition: `opacity ${transitionDuration}s`,\n        });\n\n        await new Promise(resolve => setTimeout(resolve, transitionDuration * 1000));\n      } else {\n        bgElement.css({\n          'background-image': `url(${actualBgUrl})`,\n          'background-size': 'cover',\n          'background-position': 'center',\n        });\n      }\n    } catch (error) {\n      bgElement.css({\n        'background-image': 'none',\n        'background-color': '#000',\n      });\n    }\n  }\n\n  // 扫描并渲染所有消息\n  async function scanAndRenderAllMessages() {\n    try {\n      const messages = await getChatMessages('0-{{lastMessageId}}');\n\n      const lastMessageId = messages.length > 0 ? Number(messages[0].message_id) : 0;\n\n      for (const message of messages) {\n        if (renderedMessages.has(message.message_id)) continue;\n\n        if (config.renderDepth > 0) {\n          const messageId = Number(message.message_id);\n          if (lastMessageId - messageId >= config.renderDepth) {\n            continue;\n          }\n        }\n\n        if (message.message && (message.message.includes('<gametext>') || message.message.includes('<gametext>'))) {\n          await renderGameForMessage(message.message_id);\n        }\n      }\n\n      if (config.renderDepth > 0) {\n        cleanupOldRenders(lastMessageId);\n      }\n    } catch (error) {}\n  }\n\n  // 流式传输处理函数\n  async function streamParser(fulltext) {\n    try {\n      if (streamStart === false) {\n        streamStart = true;\n        streamParsing = false;\n\n        let last_mesid = Number.parseInt(await triggerSlashWithResult('/pass {{lastMessageId}}'));\n\n        let mes_text = retrieveDisplayedMessage(last_mesid);\n        if (!mes_text || mes_text.length === 0) {\n          streamStart = false;\n          return;\n        }\n\n        streamInfo = {\n          mesid: last_mesid,\n          textLength: fulltext.length,\n          text: fulltext,\n          textCount: 0,\n          characters: {\n            L: { name: null, sprite: null },\n            C: { name: null, sprite: null },\n            R: { name: null, sprite: null },\n          },\n          currentDialogIndex: 0,\n          dialogues: [],\n          waitingForClick: true,\n          lastProcessedLine: '',\n          history: [],\n          isComplete: false,\n          originalMessageEl: mes_text,\n        };\n\n        if (mes_text && mes_text.length > 0) {\n          mes_text.attr('data-original-content', mes_text.html() || '');\n          mes_text.text(fulltext);\n        }\n\n        tempMesText = $('<div class=\"mes_text\"></div>');\n        mes_text.after(tempMesText);\n        mes_text.css('display', 'none');\n\n        try {\n          const messageRow = mes_text.closest('.mes_block');\n          if (messageRow && messageRow.length > 0) {\n            const editBtn = messageRow.find('.mes_edit');\n            if (editBtn && editBtn.length > 0) {\n              $(document)\n                .off('click.galgame_edit')\n                .on('click.galgame_edit', '.mes_edit', function (e) {\n                  const clickedMesBlock = $(this).closest('.mes_block');\n                  const mesId =\n                    clickedMesBlock.attr('mesid') ||\n                    clickedMesBlock.attr('data-mesid') ||\n                    clickedMesBlock.attr('data-id');\n\n                  if (streamInfo && streamInfo.mesid === Number(mesId)) {\n                    // 防止连续点击\n                    if (window.GALGAME_EDITING_MESSAGE) {\n                      return;\n                    }\n\n                    window.GALGAME_EDITING_MESSAGE = true;\n\n                    // 强制恢复原始消息状态\n                    forceResetStreamMessage(mesId);\n\n                    // 使用简单的刷新方案 - 更可靠且避免复杂错误处理\n                    try {\n                      // 记住当前消息ID以便重新加载后定位\n                      sessionStorage.setItem('galgame_edit_mesid', mesId);\n\n                      // 提示用户刷新页面\n                      if (confirm('为了编辑GALGAME内容，需要刷新页面。点击确定刷新页面，然后再次点击编辑按钮。')) {\n                        // 刷新页面\n                        location.reload();\n                      } else {\n                        // 用户取消了操作，清除标志\n                        window.GALGAME_EDITING_MESSAGE = false;\n                      }\n                    } catch (e) {\n                      log('准备刷新页面出错:', e);\n                      window.GALGAME_EDITING_MESSAGE = false;\n                    }\n                  }\n                });\n            }\n          }\n        } catch (editError) {\n          log('设置编辑按钮处理失败:', editError);\n        }\n\n        // 创建基本游戏HTML结构\n        const gameHTML = $('<div class=\"roleplay_galgame\"></div>');\n\n        // 添加样式和容器 - 使用原GALGAME插件的样式和类名\n        gameHTML.append(`\n          <style>\n            @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css');\n            \n            /* 基本容器样式 */\n            .galgame-container-${last_mesid} {\n              width: 360px;\n              position: relative;\n              background-color: #000;\n              background-size: cover;\n              background-position: center;\n              border-radius: 12px;\n              overflow: hidden;\n              box-shadow: 0 5px 15px rgba(0,0,0,0.2);\n              margin: 15px auto;\n              display: flex;\n              flex-direction: column;\n              user-select: none;\n              -webkit-user-select: none;\n              -moz-user-select: none;\n              -ms-user-select: none;\n              pointer-events: auto;\n              aspect-ratio: 16/9;\n              height: auto;\n            }\n            \n            @media (min-width: 768px) {\n              .galgame-container-${last_mesid} {\n                width: 100%;\n                max-width: 90%;\n              }\n            }\n            \n            /* 背景层 */\n            .galgame-bg-${last_mesid} {\n              position: absolute;\n              top: 0;\n              left: 0;\n              width: 100%;\n              height: 100%;\n              background-size: cover;\n              background-position: center;\n              z-index: 0;\n              pointer-events: none;\n            }\n            \n            /* 角色区域 */\n            .galgame-char-area-${last_mesid} {\n              flex: 1;\n              display: flex;\n              justify-content: center;\n              align-items: flex-end;\n              position: relative;\n              min-height: 70%;\n              z-index: 1;\n            }\n            \n            /* 移动端角色区域调整 */\n            @media (max-width: 767px) {\n              .galgame-char-area-${last_mesid} {\n                min-height: calc(100% - ${config.mobileDiaogueHeight}% - 20px);\n              }\n            }\n            \n            /* 角色立绘 */\n            .galgame-char-${last_mesid} {\n              max-width: 100%;\n              max-height: 120%;\n              position: absolute;\n              bottom: ${config.characterBottomOffset}%;\n              opacity: 0;\n              transition: opacity 0.3s ease-in-out, filter 0.3s ease-in-out;\n              pointer-events: none;\n            }\n            \n            .galgame-char-${last_mesid}.left {\n              left: 0;\n              transform: scaleX(1);\n            }\n            \n            .galgame-char-${last_mesid}.center {\n              left: 50%;\n              transform: translateX(-50%);\n            }\n            \n            .galgame-char-${last_mesid}.right {\n              right: 0;\n              transform: scaleX(-1);\n            }\n            \n            .galgame-char-${last_mesid}.active {\n              opacity: 1;\n            }\n            \n            .galgame-char-${last_mesid}.active.dimmed {\n              filter: brightness(0.5) grayscale(0.3);\n            }\n            \n            /* CG图片 */\n            .galgame-cg-${last_mesid} {\n              position: absolute;\n              top: 0;\n              left: 5%;\n              width: 90%;\n              height: 70%;\n              z-index: 3;\n              opacity: 0;\n              pointer-events: none;\n              transition: opacity 0.3s ease-in-out;\n              border: 6px solid white;\n              border-radius: 8px;\n              box-shadow: 0 2px 8px rgba(0,0,0,0.2);\n              background-color: white;\n              display: flex;\n              justify-content: center;\n              align-items: center;\n              overflow: hidden;\n            }\n            \n            .galgame-cg-${last_mesid} img {\n              max-width: 100%;\n              max-height: 100%;\n              object-fit: contain;\n            }\n            \n            .galgame-cg-${last_mesid}.active {\n              opacity: 1;\n            }\n            \n            /* 对话框 */\n            .galgame-dialogue-${last_mesid} {\n              background-color: rgba(255, 255, 255, 0.8);\n              backdrop-filter: blur(3px);\n              border-radius: 10px;\n              padding: 25px 18px 15px 18px;\n              margin: 10px;\n              box-shadow: 0 2px 10px rgba(0,0,0,0.15);\n              position: relative;\n              min-height: 80px;\n              z-index: 4;\n              height: ${config.dialogueHeight}%;\n              user-select: none;\n            }\n            \n            /* 移动端对话框高度调整 */\n            @media (max-width: 767px) {\n              .galgame-dialogue-${last_mesid} {\n                height: ${config.mobileDiaogueHeight}%;\n                min-height: 120px;\n              }\n            }\n            \n            /* 角色名称 */\n            .galgame-name-${last_mesid} {\n              position: absolute;\n              top: -20px;\n              left: 15px;\n              background-color: #ffacb6;\n              color: white;\n              padding: 4px 14px;\n              border-radius: 15px;\n              font-weight: bold;\n              box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n              font-size: 16px;\n              z-index: 5;\n              user-select: none;\n            }\n            \n            /* 对话文本 */\n            .galgame-text-${last_mesid} {\n              margin-top: 0;\n              color: #333;\n              font-size: 17px;\n              line-height: 1.5;\n              user-select: none;\n            }\n            \n            /* 下一步指示器 */\n            .galgame-next-${last_mesid} {\n              position: absolute;\n              bottom: 5px;\n              right: 15px;\n              font-size: 20px;\n              color: #ff69b4;\n              animation: pointer-pulse-${last_mesid} 1.5s infinite;\n              user-select: none;\n            }\n            \n            @keyframes pointer-pulse-${last_mesid} {\n              0% { transform: scale(1); opacity: 0.7; }\n              50% { transform: scale(1.1); opacity: 1; }\n              100% { transform: scale(1); opacity: 0.7; }\n            }\n            \n            .galgame-text-indicator-${last_mesid} {\n              opacity: 0.6;\n              position: absolute;\n              right: 5px;\n              bottom: 30px;\n            }\n            \n            /* 设置所有Font Awesome图标为粉红色 */\n            .galgame-container-${last_mesid} .fas {\n              color: #ff69b4;\n            }\n            \n            .galgame-choices-${last_mesid} {\n              display: flex;\n              flex-direction: column;\n              gap: 8px;\n              padding: 10px;\n              position: absolute;\n              top: 50%;\n              left: 50%;\n              transform: translate(-50%, -50%);\n              width: 80%;\n              max-width: 300px;\n              z-index: 6;\n              user-select: none;\n            }\n            \n            .galgame-choice-${last_mesid} {\n              background-color: rgba(255, 255, 255, 0.8);\n              border: 1px solid #ccc;\n              border-radius: 8px;\n              padding: 10px 15px;\n              cursor: pointer;\n              transition: all 0.2s;\n              color: #333;\n              font-weight: bold;\n              text-align: center;\n              box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n              user-select: none;\n            }\n            \n            .galgame-choice-${last_mesid}:hover {\n              background-color: rgba(240, 240, 240, 0.9);\n              transform: translateY(-2px);\n            }\n            \n            .galgame-overlay-${last_mesid} {\n              position: absolute;\n              top: 0;\n              left: 0;\n              width: 100%;\n              height: 100%;\n              background: black;\n              opacity: 0;\n              transition: opacity 0.5s;\n              pointer-events: none;\n              z-index: 7;\n            }\n            \n            .galgame-history-btn-${last_mesid} {\n              position: absolute;\n              top: 10px;\n              right: 10px;\n              background-color: rgba(255, 255, 255, 0.8);\n              color: #333;\n              border: 1px solid #ddd;\n              border-radius: 8px;\n              padding: 6px 12px;\n              font-size: 14px;\n              font-weight: bold;\n              cursor: pointer;\n              z-index: 10;\n              box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n              transition: background-color 0.2s;\n            }\n            \n            .galgame-history-btn-${last_mesid}:hover {\n              background-color: rgba(240, 240, 240, 0.9);\n            }\n            \n            .galgame-history-modal-${last_mesid} {\n              display: none;\n              position: absolute;\n              top: 0;\n              left: 0;\n              width: 100%;\n              height: 100%;\n              background-color: rgba(0, 0, 0, 0.7);\n              z-index: 20;\n            }\n            \n            .galgame-history-content-${last_mesid} {\n              position: absolute;\n              top: 50%;\n              left: 50%;\n              transform: translate(-50%, -50%);\n              width: 90%;\n              height: 80%;\n              background-color: rgba(255, 255, 255, 0.8);\n              border-radius: 12px;\n              padding: 20px;\n              overflow-y: auto;\n              max-height: 100%;\n              box-shadow: 0 5px 15px rgba(0,0,0,0.3);\n            }\n            \n            .galgame-history-title-${last_mesid} {\n              text-align: center;\n              margin-bottom: 15px;\n              padding-bottom: 10px;\n              border-bottom: 1px solid #ddd;\n              color: #333;\n              font-weight: bold;\n            }\n            \n            .galgame-history-list-${last_mesid} {\n              display: flex;\n              flex-direction: column;\n              gap: 10px;\n            }\n            \n            .galgame-history-item-${last_mesid} {\n              padding: 10px;\n              border-radius: 8px;\n              background-color: rgba(240, 240, 240, 0.8);\n            }\n            \n            .galgame-history-speaker-${last_mesid} {\n              font-weight: bold;\n              color: #ff7eb3;\n              margin-bottom: 5px;\n            }\n            \n            .galgame-history-text-${last_mesid} {\n              color: #000000;\n            }\n            \n            .galgame-history-close-${last_mesid} {\n              position: absolute;\n              top: 10px;\n              right: 10px;\n              background: none;\n              border: none;\n              font-size: 20px;\n              cursor: pointer;\n              color: #333;\n            }\n            \n            /* 晃动动画 */\n            .galgame-history-shake-${last_mesid} {\n              animation: shake-light-${last_mesid} 0.5s ease-in-out;\n            }\n            \n            @keyframes shake-light-${last_mesid} {\n              0%, 100% { transform: translateX(0) scaleX(var(--originalScaleX, 1)); }\n              10%, 30%, 50%, 70%, 90% { transform: translateX(-5px) scaleX(var(--originalScaleX, 1)); }\n              20%, 40%, 60%, 80% { transform: translateX(5px) scaleX(var(--originalScaleX, 1)); }\n            }\n            \n            .shake-center-${last_mesid} {\n              animation: shake-center-${last_mesid} 0.5s ease-in-out;\n            }\n            \n            @keyframes shake-center-${last_mesid} {\n              0%, 100% { transform: translateX(-50%) scaleX(var(--originalScaleX, 1)); }\n              10%, 30%, 50%, 70%, 90% { transform: translateX(calc(-50% - 5px)) scaleX(var(--originalScaleX, 1)); }\n              20%, 40%, 60%, 80% { transform: translateX(calc(-50% + 5px)) scaleX(var(--originalScaleX, 1)); }\n            }\n            \n            /* 统一图标颜色 */\n            .galgame-container-${last_mesid} .fas {\n              color: #ff69b4;\n            }\n            \n            /* 保持履历按钮文字颜色不变 */\n            .galgame-history-btn-${last_mesid} {\n              color: #333;\n            }\n          </style>\n          \n          <div class=\"galgame-container-${last_mesid}\">\n            <div class=\"galgame-bg-${last_mesid}\" id=\"bg-stream-${last_mesid}\"></div>\n            \n            <div class=\"galgame-char-area-${last_mesid}\">\n              <img class=\"galgame-char-${last_mesid} left\" id=\"char-left-stream-${last_mesid}\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\" alt=\"\">\n              <img class=\"galgame-char-${last_mesid} center\" id=\"char-center-stream-${last_mesid}\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\" alt=\"\">\n              <img class=\"galgame-char-${last_mesid} right\" id=\"char-right-stream-${last_mesid}\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\" alt=\"\">\n            </div>\n            \n            <div class=\"galgame-cg-${last_mesid}\" id=\"cg-stream-${last_mesid}\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\" alt=\"\"></div>\n            \n            <button class=\"galgame-history-btn-${last_mesid}\" id=\"history-btn-stream-${last_mesid}\"><i class=\"fas fa-history\"></i> 履历</button>\n            \n            <div class=\"galgame-history-modal-${last_mesid}\" id=\"history-modal-stream-${last_mesid}\">\n              <div class=\"galgame-history-content-${last_mesid}\">\n                <button class=\"galgame-history-close-${last_mesid}\" id=\"history-close-stream-${last_mesid}\"><i class=\"fas fa-times\"></i></button>\n                <div class=\"galgame-history-title-${last_mesid}\">对话履历</div>\n                <div class=\"galgame-history-list-${last_mesid}\" id=\"history-list-stream-${last_mesid}\"></div>\n              </div>\n            </div>\n            \n            <div class=\"galgame-dialogue-${last_mesid}\">\n              <div class=\"galgame-name-${last_mesid}\" id=\"name-stream-${last_mesid}\"></div>\n              <div class=\"galgame-text-${last_mesid}\" id=\"text-stream-${last_mesid}\">正在加载游戏内容...</div>\n              <div class=\"galgame-next-${last_mesid}\" id=\"next-stream-${last_mesid}\"><i class=\"fas fa-caret-down\"></i></div>\n              <div class=\"galgame-text-indicator-${last_mesid}\" id=\"indicator-stream-${last_mesid}\">0/0</div>\n            </div>\n            \n            <div class=\"galgame-choices-${last_mesid}\" id=\"choices-stream-${last_mesid}\"></div>\n            <div class=\"galgame-overlay-${last_mesid}\" id=\"overlay-stream-${last_mesid}\"></div>\n          </div>\n        `);\n\n        // 插入到DOM\n        tempMesText.append(gameHTML);\n\n        // 添加点击事件处理\n        $(`.galgame-container-${last_mesid}`, tempMesText).on('click', function (e) {\n          e.stopPropagation();\n\n          if (streamInfo.processing) return;\n          if (streamInfo.showingChoices) return;\n\n          log('流式界面接收到点击事件，推进对话');\n          processStreamNextDialogue();\n        });\n\n        // 设置履历按钮点击事件\n        $(`#history-btn-stream-${last_mesid}`, tempMesText).on('click', function (e) {\n          e.stopPropagation();\n          showStreamHistoryModal(last_mesid);\n        });\n\n        // 设置履历关闭按钮点击事件\n        $(`#history-close-stream-${last_mesid}`, tempMesText).on('click', function (e) {\n          e.stopPropagation();\n          hideStreamHistoryModal(last_mesid);\n        });\n\n        // 存储元素引用\n        streamInfo.nameElement = $(`#name-stream-${last_mesid}`, tempMesText);\n        streamInfo.textElement = $(`#text-stream-${last_mesid}`, tempMesText);\n        streamInfo.portraitsElement = $(`.galgame-char-area-${last_mesid}`, tempMesText);\n        streamInfo.sceneElement = $(`#bg-stream-${last_mesid}`, tempMesText);\n        streamInfo.nextElement = $(`#next-stream-${last_mesid}`, tempMesText);\n        streamInfo.indicatorElement = $(`#indicator-stream-${last_mesid}`, tempMesText);\n        streamInfo.leftCharElement = $(`#char-left-stream-${last_mesid}`, tempMesText);\n        streamInfo.centerCharElement = $(`#char-center-stream-${last_mesid}`, tempMesText);\n        streamInfo.rightCharElement = $(`#char-right-stream-${last_mesid}`, tempMesText);\n        streamInfo.cgElement = $(`#cg-stream-${last_mesid}`, tempMesText);\n        streamInfo.choicesElement = $(`#choices-stream-${last_mesid}`, tempMesText);\n        streamInfo.overlayElement = $(`#overlay-stream-${last_mesid}`, tempMesText);\n        streamInfo.historyListElement = $(`#history-list-stream-${last_mesid}`, tempMesText);\n\n        // 初始状态\n        streamInfo.nameElement.hide();\n        streamInfo.nextElement.hide();\n\n        // 解析初始文本\n        streamParsing = false;\n        processStreamContent(fulltext);\n      } else if (streamParsing === false && streamInfo !== undefined) {\n        streamParsing = true;\n\n        // 获取新增文本\n        const incremental_text = fulltext.slice(streamInfo.textLength);\n\n        // 如果没有新增文本，不处理\n        if (incremental_text.length === 0) {\n          log('无新增文本，跳过处理');\n          streamParsing = false;\n          return;\n        }\n\n        streamInfo.text += incremental_text;\n        streamInfo.textLength = streamInfo.text.length;\n\n        log('接收流式文本，新增长度:', incremental_text.length, '总长度:', streamInfo.textLength);\n\n        // 保存完整文本到原始消息元素，方便编辑查看\n        if (streamInfo.originalMessageEl && streamInfo.originalMessageEl.length > 0) {\n          streamInfo.originalMessageEl.text(streamInfo.text);\n        }\n\n        // 检查是否包含结束标记\n        if (incremental_text.includes('</gametext>')) {\n          streamInfo.isComplete = true;\n\n          // 流式传输完成，确保更新原始消息元素，但在延迟后执行\n          // 延长等待时间，避免与其他事件冲突\n          setTimeout(() => {\n            // 检查是否处于编辑状态，如果是则不处理完成逻辑\n            if (!window.GALGAME_EDITING_MESSAGE) {\n              finishStreamGeneration();\n            } else {\n              log('检测到编辑状态，延迟处理流式完成');\n              // 再等待一段时间\n              setTimeout(() => {\n                finishStreamGeneration();\n              }, 1000);\n            }\n          }, 1000);\n        }\n\n        // 直接处理文本内容\n        processStreamContent(streamInfo.text);\n\n        streamParsing = false;\n      }\n    } catch (error) {\n      log('流式解析出错:', error, '错误堆栈:', error.stack);\n      streamParsing = false;\n    }\n  }\n\n  // 处理流式内容\n  function processStreamContent(content) {\n    try {\n      if (!streamInfo || !tempMesText) {\n        return;\n      }\n\n      try {\n        if (streamInfo.textElement && streamInfo.textElement.text() === '正在加载游戏内容...') {\n          streamInfo.textElement.text('');\n        }\n      } catch (e) {}\n\n      let scriptText = '';\n      const gameTextMatch = content.match(gameTextRegex) || content.match(directGameTextRegex);\n\n      if (gameTextMatch) {\n        scriptText = gameTextMatch[1].trim();\n      } else {\n        scriptText = content;\n      }\n\n      const lastOpenBracket = scriptText.lastIndexOf('[');\n      const lastCloseBracket = scriptText.lastIndexOf(']');\n\n      if (lastOpenBracket > lastCloseBracket) {\n        // 存在不完整命令，移除最后一个不完整的命令部分\n        scriptText = scriptText.substring(0, lastOpenBracket);\n      }\n\n      // 预处理：确保所有命令都是完整的\n      scriptText = scriptText.replace(/\\[show\\|[^\\]]*$/g, ''); // 移除不完整的show命令\n      scriptText = scriptText.replace(/\\[bg\\|[^\\]]*$/g, ''); // 移除不完整的bg命令\n      scriptText = scriptText.replace(/\\[cg\\|[^\\]]*$/g, ''); // 移除不完整的cg命令\n      scriptText = scriptText.replace(/\\[action\\|[^\\]]*$/g, ''); // 移除不完整的action命令\n\n      // 按行处理内容\n      const lines = scriptText.split('\\n');\n\n      // 重置流式对话数组\n      const prevDialogues = streamInfo.dialogues || [];\n      const prevCount = prevDialogues.length;\n      streamInfo.dialogues = [];\n\n      // 提取所有命令和对话\n      for (const line of lines) {\n        const trimmedLine = line.trim();\n        if (!trimmedLine) continue;\n\n        // 跳过可能是不完整命令的行\n        if (trimmedLine.startsWith('[') && !trimmedLine.endsWith(']')) {\n          continue;\n        }\n\n        // 解析对话行\n        const dialogueMatch = trimmedLine.match(dialogueRegex);\n        if (dialogueMatch) {\n          let character = dialogueMatch[1].trim() || '旁白';\n          const position = dialogueMatch[2].trim().toUpperCase() || null;\n          const sprite = dialogueMatch[3].trim();\n          let text = dialogueMatch[4].trim();\n\n          // 检查character是否被错误解析为命令\n          if (character.startsWith('[') && !character.endsWith(']')) {\n            continue;\n          }\n\n          // 检查text是否包含未闭合的命令片段\n          if ((text.includes('[') && !text.includes(']')) || (!text.includes('[') && text.includes(']'))) {\n            text = text.replace(/\\[[^\\]]*$/g, ''); // 移除不完整的左括号开始的片段\n            text = text.replace(/^[^\\[]*\\]/g, ''); // 移除不完整的右括号结束的片段\n          }\n\n          // 处理内联动作指令\n          let inlineAction = null;\n          const actionRegex = /\\[action\\|([^|]+)\\|([^|]+)(?:\\|([^\\]]+))?\\]$/;\n          const actionMatch = text.match(actionRegex);\n\n          if (actionMatch) {\n            // 如果有内联动作，移除文本中的动作指令部分\n            text = text.replace(actionRegex, '').trim();\n\n            inlineAction = {\n              target: actionMatch[1],\n              action: actionMatch[2],\n              params: actionMatch[3] ? actionMatch[3].split('|') : [],\n            };\n          }\n\n          // 最后的安全检查 - 确保所有值都有意义\n          if (character && character.length < 20 && !character.includes('[') && !character.includes(']')) {\n            const dialogData = {\n              type: 'dialogue',\n              character: character,\n              position: position,\n              sprite: sprite,\n              text: text,\n              inlineAction: inlineAction,\n              processed: false,\n            };\n\n            streamInfo.dialogues.push(dialogData);\n          }\n          continue;\n        }\n\n        // 解析命令行\n        const commandMatch = trimmedLine.match(commandRegex);\n        if (commandMatch) {\n          const fullCommand = commandMatch[1];\n          const parts = fullCommand.split('|');\n          const command = parts[0].trim();\n          const args = parts.slice(1).map(arg => arg.trim());\n\n          streamInfo.dialogues.push({\n            type: 'command',\n            command: command,\n            args: args,\n            processed: false,\n          });\n        }\n      }\n\n      // 更新对话数量\n      streamInfo.textCount = streamInfo.dialogues.length;\n\n      // 检查是否有新对话添加，如果当前索引超过了对话数量，重置索引\n      if (streamInfo.currentDialogIndex >= streamInfo.dialogues.length) {\n        streamInfo.currentDialogIndex = 0;\n      }\n\n      // 更新对话计数指示器\n      if (streamInfo.textCount > 0) {\n        streamInfo.indicatorElement.text(`${streamInfo.currentDialogIndex + 1}/${streamInfo.textCount}`);\n      }\n\n      // 初始化第一条对话/命令\n      if (streamInfo.dialogues.length > 0 && !streamInfo.initialized) {\n        streamInfo.initialized = true;\n        processStreamNextDialogue();\n      }\n    } catch (error) {\n      log('处理流式内容出错:', error);\n\n      // 出错后尝试显示内容\n      if (streamInfo && streamInfo.textElement) {\n        try {\n          streamInfo.textElement.text('正在生成内容中，请稍候...');\n        } catch (e) {}\n      }\n    }\n  }\n\n  // 处理下一条流式对话/命令\n  function processStreamNextDialogue() {\n    try {\n      if (!streamInfo) return;\n\n      // 如果正在流式完成处理或编辑中，跳过\n      if (window.GALGAME_FINISHING_STREAM || window.GALGAME_EDITING_MESSAGE) {\n        return;\n      }\n\n      // 防止重复处理\n      if (streamInfo.processing) {\n        return;\n      }\n\n      streamInfo.processing = true;\n\n      // 检查是否有下一条对话/命令\n      if (streamInfo.currentDialogIndex >= streamInfo.dialogues.length) {\n        // 检查是否所有对话都处理完毕且消息已完成\n        if (streamInfo.isComplete && !document.querySelector(`.galgame-dialogue-${streamInfo.mesid} .replay-button`)) {\n          // 创建重新播放按钮\n          const replayButton = $(\n            `<button class=\"replay-button\" style=\"position:absolute; bottom:5px; left:15px; padding:5px 15px; background-color:#ff69b4; color:white; border:none; border-radius:5px; cursor:pointer;\"><i class=\"fas fa-redo-alt\"></i> 重新播放</button>`,\n          );\n          replayButton.on('click', function (e) {\n            e.stopPropagation();\n\n            // 如果流式完成处理或编辑中，不处理点击\n            if (window.GALGAME_FINISHING_STREAM || window.GALGAME_EDITING_MESSAGE) {\n              return;\n            }\n\n            restartStreamDialogue();\n          });\n\n          $(`.galgame-dialogue-${streamInfo.mesid}`, tempMesText).append(replayButton);\n        }\n\n        streamInfo.processing = false;\n        return;\n      }\n\n      const currentItem = streamInfo.dialogues[streamInfo.currentDialogIndex];\n\n      // 确保界面可访问\n      if (!tempMesText || !tempMesText.is(':visible')) {\n        streamInfo.processing = false;\n        return;\n      }\n\n      if (currentItem.type === 'dialogue') {\n        // 处理对话\n        const character = currentItem.character;\n        const position = currentItem.position;\n        const sprite = currentItem.sprite;\n        const text = currentItem.text;\n        const inlineAction = currentItem.inlineAction;\n\n        // 安全检查 - 确保character不是命令片段\n        if (character && !character.includes('[') && !character.includes(']')) {\n          // 设置角色名称\n          if (character === '旁白') {\n            streamInfo.nameElement.hide();\n            // 对于旁白对话，不应该亮起任何角色，但也不要额外暗化\n          } else {\n            streamInfo.nameElement.text(character).show();\n            \n            // 设置角色立绘\n            if (position && sprite) {\n              processStreamCharacter(character, position, sprite);\n            } else {\n              // 如果只有角色名没有立绘和位置，尝试找到该角色并点亮\n              for (const p in streamInfo.characters) {\n                if (streamInfo.characters[p].name === character) {\n                  const element = p === 'L' \n                    ? streamInfo.leftCharElement \n                    : p === 'C' \n                      ? streamInfo.centerCharElement \n                      : streamInfo.rightCharElement;\n                  element.removeClass('dimmed').addClass('active');\n                  \n                  // 使其他角色变暗\n                  for (const otherP in streamInfo.characters) {\n                    if (otherP !== p && streamInfo.characters[otherP].name) {\n                      const otherElement = otherP === 'L' \n                        ? streamInfo.leftCharElement \n                        : otherP === 'C' \n                          ? streamInfo.centerCharElement \n                          : streamInfo.rightCharElement;\n                      otherElement.addClass('dimmed');\n                    }\n                  }\n                  break;\n                }\n              }\n            }\n          }\n\n          // 显示对话文本（使用打字机效果）\n          streamInfo.nextElement.hide();\n\n          // 格式化文本，确保特殊标记被正确处理\n          const cleanText = text.replace(/\\[[^\\]]*\\]/g, ''); // 移除所有可能遗留的命令\n          const formattedText = renderText(cleanText);\n\n          streamTypewriterEffect(formattedText, () => {\n            // 如果有内联动作，在文本完成后执行\n            if (inlineAction) {\n              executeStreamAction(inlineAction.target, inlineAction.action, inlineAction.params);\n            }\n\n            // 添加到履历\n            addStreamToHistory(streamInfo.mesid, character, cleanText);\n\n            streamInfo.nextElement.show();\n            streamInfo.currentDialogIndex++;\n            streamInfo.indicatorElement.text(\n              `${Math.min(streamInfo.currentDialogIndex, streamInfo.dialogues.length)}/${streamInfo.textCount}`,\n            );\n            streamInfo.processing = false;\n          });\n        } else {\n          // 跳过无效角色名的对话\n          streamInfo.currentDialogIndex++;\n          streamInfo.processing = false;\n          processStreamNextDialogue();\n        }\n      } else if (currentItem.type === 'command') {\n        // 处理命令\n        const command = currentItem.command;\n        const args = currentItem.args;\n\n        processStreamCommand(command, args).then(() => {\n          streamInfo.currentDialogIndex++;\n          streamInfo.indicatorElement.text(\n            `${Math.min(streamInfo.currentDialogIndex, streamInfo.dialogues.length)}/${streamInfo.textCount}`,\n          );\n          streamInfo.processing = false;\n\n          // 如果是自动执行的命令（背景、CG等），自动继续下一条\n          if (command !== 'choice' && command !== 'wait') {\n            setTimeout(() => {\n              processStreamNextDialogue();\n            }, 50);\n          }\n        });\n      } else {\n        streamInfo.currentDialogIndex++;\n        streamInfo.processing = false;\n        processStreamNextDialogue();\n      }\n    } catch (error) {\n      log('处理流式对话出错:', error);\n      if (streamInfo) {\n        streamInfo.processing = false;\n      }\n    }\n  }\n\n  // 执行流式角色动作\n  function executeStreamAction(targetName, actionType, params = []) {\n    try {\n      if (!streamInfo) return;\n\n      log('执行流式角色动作:', targetName, actionType, params);\n\n      let targetElement = null;\n      let pos = null;\n\n      // 查找目标角色\n      for (const p in streamInfo.characters) {\n        if (streamInfo.characters[p].name === targetName) {\n          pos = p === 'L' ? 'left' : p === 'C' ? 'center' : 'right';\n          targetElement =\n            pos === 'left'\n              ? streamInfo.leftCharElement\n              : pos === 'center'\n              ? streamInfo.centerCharElement\n              : streamInfo.rightCharElement;\n          break;\n        }\n      }\n\n      if (!targetElement || !targetElement.length) {\n        log('找不到动作目标:', targetName);\n        return;\n      }\n\n      if (actionType === 'shake') {\n        const intensity = params[0] || 'light';\n\n        let originalScaleX = 1;\n        if (pos === 'right') {\n          originalScaleX = -1;\n        }\n\n        targetElement.css('--originalScaleX', originalScaleX);\n\n        // 为所有位置的角色使用通用的晃动逻辑\n        if (pos === 'center') {\n          targetElement.removeClass(`shake-light-${streamInfo.mesid} shake-center-${streamInfo.mesid}`);\n          void targetElement[0].offsetWidth; // 强制重排\n          targetElement.addClass(`shake-center-${streamInfo.mesid}`);\n\n          setTimeout(() => {\n            targetElement.removeClass(`shake-center-${streamInfo.mesid}`);\n            targetElement.css('transform', 'translateX(-50%)');\n          }, 500);\n        } else if (pos === 'left') {\n          // 左侧角色特定处理\n          targetElement.removeClass(`shake-light-${streamInfo.mesid} shake-center-${streamInfo.mesid}`);\n          void targetElement[0].offsetWidth; // 强制重排\n          \n          // 保存原始样式以便还原\n          const originalTransition = targetElement.css('transition');\n          targetElement.css('transition', 'none');\n          \n          // 添加自定义动画\n          targetElement.css('animation', `shake-light-${streamInfo.mesid} 0.5s ease-in-out`);\n          \n          setTimeout(() => {\n            targetElement.css('animation', '');\n            targetElement.css('transition', originalTransition);\n            targetElement.css('transform', 'scaleX(1)');\n          }, 500);\n        } else if (pos === 'right') {\n          // 右侧角色特定处理\n          targetElement.removeClass(`shake-light-${streamInfo.mesid} shake-center-${streamInfo.mesid}`);\n          void targetElement[0].offsetWidth; // 强制重排\n          \n          // 保存原始样式以便还原\n          const originalTransition = targetElement.css('transition');\n          targetElement.css('transition', 'none');\n          \n          // 添加自定义动画\n          targetElement.css('animation', `shake-light-${streamInfo.mesid} 0.5s ease-in-out`);\n          \n          setTimeout(() => {\n            targetElement.css('animation', '');\n            targetElement.css('transition', originalTransition);\n            targetElement.css('transform', 'scaleX(-1)');\n          }, 500);\n        }\n      } else if (actionType === 'jump_up') {\n        targetElement.css('transition', 'transform 0.15s ease-out');\n\n        if (pos === 'center') {\n          targetElement.css('transform', 'translateX(-50%) translateY(-20px)');\n\n          setTimeout(() => {\n            targetElement.css('transition', 'transform 0.15s ease-in');\n            targetElement.css('transform', 'translateX(-50%)');\n          }, 150);\n        } else {\n          targetElement.css('transform', 'translateY(-20px) ' + (pos === 'right' ? 'scaleX(-1)' : 'scaleX(1)'));\n\n          setTimeout(() => {\n            targetElement.css('transition', 'transform 0.15s ease-in');\n            targetElement.css('transform', pos === 'right' ? 'scaleX(-1)' : 'scaleX(1)');\n          }, 150);\n        }\n      } else if (actionType === 'jump_down') {\n        targetElement.css('transition', 'transform 0.15s ease-out');\n\n        if (pos === 'center') {\n          targetElement.css('transform', 'translateX(-50%) translateY(10px)');\n\n          setTimeout(() => {\n            targetElement.css('transition', 'transform 0.15s ease-in');\n            targetElement.css('transform', 'translateX(-50%)');\n          }, 150);\n        } else {\n          targetElement.css('transform', 'translateY(10px) ' + (pos === 'right' ? 'scaleX(-1)' : 'scaleX(1)'));\n\n          setTimeout(() => {\n            targetElement.css('transition', 'transform 0.15s ease-in');\n            targetElement.css('transform', pos === 'right' ? 'scaleX(-1)' : 'scaleX(1)');\n          }, 150);\n        }\n      }\n    } catch (error) {\n      log('执行流式角色动作出错:', error);\n    }\n  }\n\n  // 流式打字机效果\n  function streamTypewriterEffect(text, onComplete) {\n    if (!streamInfo || !streamInfo.textElement) {\n      if (onComplete) onComplete();\n      return;\n    }\n\n    streamInfo.textElement.empty();\n\n    if (!text || text.length === 0) {\n      if (onComplete) onComplete();\n      return;\n    }\n\n    safeExecute(\n      async () => {\n        // 检查文本是否包含HTML标签（如果renderText生成了HTML）\n        const hasHtml = /<[a-z][\\s\\S]*>/i.test(text);\n        const speed = config.typewriterSpeed;\n\n        if (hasHtml) {\n          // 使用html方法设置带标签的文本\n          let i = 0;\n          let tempText = '';\n\n          return new Promise(resolve => {\n            function typeHtml() {\n              if (i < text.length) {\n                tempText += text.charAt(i);\n                streamInfo.textElement.html(tempText);\n                i++;\n                setTimeout(typeHtml, speed);\n              } else {\n                resolve();\n              }\n            }\n\n            typeHtml();\n          });\n        } else {\n          // 使用普通文本方法\n          let i = 0;\n\n          return new Promise(resolve => {\n            function type() {\n              if (i < text.length) {\n                streamInfo.textElement.text(streamInfo.textElement.text() + text.charAt(i));\n                i++;\n                setTimeout(type, speed);\n              } else {\n                resolve();\n              }\n            }\n\n            type();\n          });\n        }\n      },\n      null,\n      '流式打字机效果出错',\n    ).then(() => {\n      // 确保文本显示\n      if (!streamInfo || !streamInfo.textElement.text()) {\n        streamInfo.textElement.html(text);\n      }\n      if (onComplete) onComplete();\n    });\n  }\n\n  // 处理流式命令\n  async function processStreamCommand(command, args) {\n    try {\n      if (!streamInfo) return;\n\n      switch (command) {\n        case 'bg':\n          await processStreamBackground(args[0], args[1], args[2]);\n          break;\n\n        case 'show':\n          processStreamCharacter(args[0], args[1].toUpperCase(), args[2]);\n          break;\n\n        case 'hide':\n          hideStreamCharacter(args[0]);\n          break;\n\n        case 'hide_all':\n          hideStreamCharacter('L');\n          hideStreamCharacter('C');\n          hideStreamCharacter('R');\n          break;\n\n        case 'cg':\n          showStreamCG(args[0]);\n          break;\n\n        case 'hide_cg':\n          hideStreamCG();\n          break;\n\n        case 'action':\n          executeStreamAction(args[0], args[1], args.slice(2));\n          break;\n\n        case 'wait':\n          const waitTime = parseFloat(args[0]) * 1000 || 500;\n          streamInfo.nextElement.hide();\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n          streamInfo.nextElement.show();\n          break;\n\n        case 'choice':\n          await showStreamChoices(args);\n          break;\n\n        case 'effect':\n          const effectType = args[0];\n          const effectParams = args.slice(1);\n\n          await executeStreamEffect(effectType, effectParams);\n          break;\n      }\n    } catch (error) {\n      log(`处理流式命令出错: ${command}`, error);\n    }\n  }\n\n  // 执行流式特效\n  async function executeStreamEffect(effectType, effectParams) {\n    try {\n      if (!streamInfo || !streamInfo.overlayElement) return;\n\n      if (effectType === 'screen_flash') {\n        streamInfo.overlayElement.css({\n          opacity: '0.8',\n          background: 'white',\n          transition: 'opacity 0.1s',\n        });\n\n        await new Promise(resolve => setTimeout(resolve, 100));\n\n        streamInfo.overlayElement.css({\n          opacity: '0',\n          transition: 'opacity 0.1s',\n        });\n\n        await new Promise(resolve => setTimeout(resolve, 100));\n      } else if (effectType === 'fade_to_black') {\n        const duration = effectParams[0] ? parseFloat(effectParams[0]) : 0.5;\n        streamInfo.overlayElement.css({\n          opacity: '0',\n          background: 'black',\n          transition: `opacity ${duration}s`,\n        });\n\n        await new Promise(resolve => setTimeout(resolve, 10));\n\n        streamInfo.overlayElement.css('opacity', '1');\n\n        await new Promise(resolve => setTimeout(resolve, duration * 1000));\n      } else if (effectType === 'fade_from_black') {\n        const duration = effectParams[0] ? parseFloat(effectParams[0]) : 0.5;\n        streamInfo.overlayElement.css({\n          opacity: '1',\n          background: 'black',\n          transition: `opacity ${duration}s`,\n        });\n\n        await new Promise(resolve => setTimeout(resolve, 10));\n\n        streamInfo.overlayElement.css('opacity', '0');\n\n        await new Promise(resolve => setTimeout(resolve, duration * 1000));\n      }\n    } catch (error) {\n      log('执行流式特效出错:', error);\n    }\n  }\n\n  // 显示流式选项\n  async function showStreamChoices(choices) {\n    try {\n      if (!streamInfo || !streamInfo.choicesElement) return;\n\n      streamInfo.showingChoices = true;\n      streamInfo.nextElement.hide();\n\n      const choicesContainer = streamInfo.choicesElement;\n      choicesContainer.empty();\n\n      const choiceOverlay = $(\n        `<div style=\"position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:4;\"></div>`,\n      );\n      $(`.galgame-container-${streamInfo.mesid}`, tempMesText).append(choiceOverlay);\n\n      log('处理流式选项，参数:', choices);\n\n      for (let i = 0; i < choices.length; i++) {\n        const choice = choices[i];\n        let text = choice.trim();\n        const tagIndex = text.indexOf('>');\n        if (tagIndex !== -1) {\n          text = text.substring(0, tagIndex).trim();\n        }\n\n        log(`创建流式选项: \"${text}\"`);\n\n        const choiceClass = `galgame-choice-${streamInfo.mesid}`;\n        const choiceElement = $(`<div class=\"${choiceClass}\">${text}</div>`);\n\n        choiceElement.on('click', function (e) {\n          e.stopPropagation();\n          log(`选择了选项: \"${text}\"`);\n\n          choicesContainer.empty();\n          choiceOverlay.remove();\n          streamInfo.showingChoices = false;\n\n          if (typeof triggerSlash === 'function') {\n            triggerSlash(`/setinput ${text}`);\n          }\n\n          streamInfo.currentDialogIndex++;\n          processStreamNextDialogue();\n        });\n\n        choicesContainer.append(choiceElement);\n      }\n    } catch (error) {\n      log('显示流式选项出错:', error);\n      streamInfo.showingChoices = false;\n    }\n  }\n\n  // 处理流式背景\n  async function processStreamBackground(bgUrl, transitionType, duration) {\n    try {\n      if (!streamInfo || !streamInfo.sceneElement) return;\n\n      // 处理背景URL\n      const imageInfo = resolveImageUrl(bgUrl, 'bg');\n      const actualBgUrl = imageInfo ? imageInfo.url : null;\n\n      // 设置背景\n      if (actualBgUrl && actualBgUrl.startsWith('http')) {\n        if (transitionType === 'fade') {\n          const transitionDuration = duration ? parseFloat(duration) : 0.5;\n\n          streamInfo.overlayElement.css({\n            opacity: '0',\n            background: '#000',\n            transition: `opacity ${transitionDuration}s`,\n          });\n\n          await new Promise(resolve => setTimeout(resolve, 10));\n\n          streamInfo.overlayElement.css('opacity', '1');\n\n          await new Promise(resolve => setTimeout(resolve, transitionDuration * 1000));\n\n          streamInfo.sceneElement.css({\n            'background-image': `url(${actualBgUrl})`,\n            'background-size': 'cover',\n            'background-position': 'center',\n          });\n\n          await new Promise(resolve => setTimeout(resolve, 50));\n\n          streamInfo.overlayElement.css({\n            opacity: '0',\n            transition: `opacity ${transitionDuration}s`,\n          });\n\n          await new Promise(resolve => setTimeout(resolve, transitionDuration * 1000));\n        } else {\n          streamInfo.sceneElement.css({\n            'background-image': `url(${actualBgUrl})`,\n            'background-size': 'cover',\n            'background-position': 'center',\n          });\n        }\n      } else {\n        streamInfo.sceneElement.css({\n          'background-image': 'none',\n          'background-color': '#000',\n        });\n      }\n    } catch (error) {\n      log('处理流式背景出错:', error);\n    }\n  }\n\n  function setupEventListeners() {\n    eventOn(tavern_events.CHARACTER_MESSAGE_RENDERED, async messageId => {\n      try {\n        // 检查是否在流式生成完成处理阶段，如果是则忽略\n        if (window.GALGAME_FINISHING_STREAM) {\n          return;\n        }\n\n        // 检查渲染深度限制\n        if (config.renderDepth > 0) {\n          const lastMessageId = await getLastMessageId();\n          if (lastMessageId - Number(messageId) >= config.renderDepth) {\n            // 如果已经渲染，则清理它\n            const $message = retrieveDisplayedMessage(messageId);\n            if ($message && $message.find('.roleplay_galgame').length > 0) {\n              $message.find('.roleplay_galgame').remove();\n              if (renderedMessages.has(messageId)) {\n                renderedMessages.delete(messageId);\n              }\n              if (gameStates[messageId]) {\n                delete gameStates[messageId];\n              }\n            }\n\n            return;\n          }\n        }\n\n        // 检查是否是当前流式处理的消息\n        if (streamInfo && streamInfo.mesid === Number(messageId)) {\n          // 如果流式界面已渲染则忽略\n          if (tempMesText && tempMesText.length > 0 && tempMesText.is(':visible')) {\n            return;\n          }\n\n          // 如果流式生成已完成但DOM未重置，保持当前状态\n          if (streamInfo.generationComplete && !streamInfo.domProcessComplete) {\n            return;\n          }\n        }\n\n        await renderGameForMessage(messageId);\n      } catch (error) {\n        log('处理新消息失败:', messageId, error);\n      }\n    });\n\n    eventOn(tavern_events.MESSAGE_UPDATED, async messageId => {\n      try {\n        // 检查是否在流式生成完成处理阶段，如果是则忽略\n        if (window.GALGAME_FINISHING_STREAM) {\n          return;\n        }\n\n        // 检查渲染深度限制\n        if (config.renderDepth > 0) {\n          const lastMessageId = await getLastMessageId();\n          if (lastMessageId - Number(messageId) >= config.renderDepth) {\n            // 如果已经渲染，则清理它\n            const $message = retrieveDisplayedMessage(messageId);\n            if ($message && $message.find('.roleplay_galgame').length > 0) {\n              $message.find('.roleplay_galgame').remove();\n              if (renderedMessages.has(messageId)) {\n                renderedMessages.delete(messageId);\n              }\n              if (gameStates[messageId]) {\n                delete gameStates[messageId];\n              }\n            }\n\n            return;\n          }\n        }\n\n        // 检查是否是流式处理中的消息\n        if (streamInfo && streamInfo.mesid === Number(messageId)) {\n          // 检查流式是否已经完成，如果完成则尝试应用编辑\n          if (streamInfo.generationComplete) {\n            // 如果编辑框已打开，不进行处理\n            if ($('.edit_textarea').is(':visible')) {\n              return;\n            }\n\n            // 显示原始消息并隐藏临时UI\n            if (streamInfo.originalMessageEl && streamInfo.originalMessageEl.length > 0) {\n              // 在切换前保存游戏状态\n              const savedGameState = {\n                currentIndex: streamInfo.currentDialogIndex,\n                characters: streamInfo.characters,\n                history: streamInfo.history,\n              };\n\n              // 移除临时UI并显示原始消息\n              streamInfo.originalMessageEl.css('display', '');\n\n              if (tempMesText) {\n                tempMesText.remove();\n                tempMesText = null;\n              }\n\n              // 重置流式状态，但保留一些游戏数据\n              const oldMesId = streamInfo.mesid;\n              streamInfo = undefined;\n              streamStart = false;\n\n              // 重新渲染游戏内容\n              if (renderedMessages.has(messageId)) {\n                renderedMessages.delete(messageId);\n              }\n\n              delete gameStates[messageId];\n\n              // 延迟重新渲染，确保DOM已更新\n              setTimeout(async () => {\n                try {\n                  await renderGameForMessage(messageId);\n\n                  // 如果新渲染的游戏存在，尝试恢复状态\n                  if (gameStates[messageId]) {\n                    // 尝试恢复状态\n                    gameStates[messageId].currentIndex = savedGameState.currentIndex;\n                    // 其他状态恢复...\n                  }\n                } catch (e) {\n                  log('重新渲染游戏内容失败:', e);\n                }\n              }, 100);\n            }\n            return;\n          }\n\n          // 如果流式生成未完成，不处理更新\n          return;\n        }\n\n        // 正常处理其他消息更新\n        if (renderedMessages.has(messageId)) {\n          renderedMessages.delete(messageId);\n          delete gameStates[messageId];\n        }\n        await renderGameForMessage(messageId);\n      } catch (error) {\n        log('处理消息更新失败:', messageId, error);\n      }\n    });\n\n    eventOn(tavern_events.CHAT_CHANGED, async () => {\n      try {\n        renderedMessages.clear();\n\n        for (const id in gameStates) {\n          delete gameStates[id];\n        }\n\n        // 重置流式状态\n        streamInfo = undefined;\n        streamStart = false;\n        if (tempMesText) {\n          tempMesText.remove();\n          tempMesText = null;\n        }\n\n        await scanAndRenderAllMessages();\n      } catch (error) {\n        log('处理聊天变更失败:', error);\n      }\n    });\n\n    eventOn(tavern_events.MESSAGE_DELETED, () => {\n      setTimeout(async () => {\n        try {\n          renderedMessages.clear();\n\n          for (const id in gameStates) {\n            delete gameStates[id];\n          }\n\n          // 重置流式状态\n          if (streamInfo) {\n            streamInfo = undefined;\n            streamStart = false;\n            if (tempMesText) {\n              tempMesText.remove();\n              tempMesText = null;\n            }\n          }\n\n          await scanAndRenderAllMessages();\n        } catch (error) {\n          log('处理消息删除失败:', error);\n        }\n      }, 1000);\n    });\n\n    // 添加流式传输事件监听\n    eventOn(tavern_events.STREAM_TOKEN_RECEIVED, streamParser);\n\n    // 添加流式传输结束事件监听\n    eventOn(tavern_events.GENERATION_STOPPED, () => {\n      try {\n        if (streamInfo && !streamInfo.isComplete) {\n          streamInfo.isComplete = true;\n          finishStreamGeneration();\n        }\n      } catch (error) {\n        log('处理生成停止事件失败:', error);\n      }\n    });\n  }\n\n  // 初始化并启动插件\n  $(async function () {\n    try {\n      log('初始化GALGAME演出插件...');\n\n      // 设置事件监听\n      setupEventListeners();\n\n      // 检查是否有编辑意图\n      try {\n        const editMesId = sessionStorage.getItem('galgame_edit_mesid');\n        if (editMesId) {\n          // 清除存储\n          sessionStorage.removeItem('galgame_edit_mesid');\n\n          log('检测到编辑意图，准备打开编辑对话框:', editMesId);\n\n          // 延迟执行确保页面加载完成\n          setTimeout(() => {\n            try {\n              // 查找并点击编辑按钮\n              const mesBlock = $(`[mesid=\"${editMesId}\"], [data-mesid=\"${editMesId}\"], [data-id=\"${editMesId}\"]`);\n              if (mesBlock.length > 0) {\n                const editBtn = mesBlock.find('.mes_edit');\n                if (editBtn.length > 0) {\n                  // 模拟原生点击\n                  editBtn[0].click();\n                }\n              }\n            } catch (e) {\n              log('自动点击编辑按钮失败:', e);\n            }\n          }, 1000);\n        }\n      } catch (e) {}\n\n      // 扫描现有消息\n      await scanAndRenderAllMessages();\n\n      log('GALGAME演出插件初始化完成');\n    } catch (error) {\n      log('初始化GALGAME演出插件失败:', error);\n    }\n  });\n\n  // 处理流式角色\n  function processStreamCharacter(character, position, sprite) {\n    try {\n      if (!streamInfo) return;\n\n      position = position.toUpperCase();\n      if (!['L', 'C', 'R'].includes(position)) {\n        position = 'C';\n      }\n\n      // 获取对应位置的元素\n      let charElement;\n      if (position === 'L') {\n        charElement = streamInfo.leftCharElement;\n      } else if (position === 'C') {\n        charElement = streamInfo.centerCharElement;\n      } else if (position === 'R') {\n        charElement = streamInfo.rightCharElement;\n      }\n\n      if (!charElement) return;\n      \n      // 确保当前角色不被暗化\n      charElement.removeClass('dimmed');\n\n      // 检查是否已经在其他位置显示该角色\n      for (const p in streamInfo.characters) {\n        if (p !== position && streamInfo.characters[p].name === character) {\n          const otherElement =\n            p === 'L'\n              ? streamInfo.leftCharElement\n              : p === 'C'\n              ? streamInfo.centerCharElement\n              : streamInfo.rightCharElement;\n\n          if (otherElement) {\n            otherElement.removeClass('active');\n          }\n\n          streamInfo.characters[p].name = null;\n          streamInfo.characters[p].sprite = null;\n        }\n      }\n\n      // 处理角色图片URL\n      const imageInfo = resolveImageUrl(sprite, 'char');\n      const actualSpriteUrl = imageInfo ? imageInfo.url : null;\n\n      // 更新角色状态\n      streamInfo.characters[position] = {\n        name: character,\n        sprite: actualSpriteUrl || null,\n      };\n\n      if (actualSpriteUrl && actualSpriteUrl.startsWith('http')) {\n        const img = new Image();\n        img.crossOrigin = 'anonymous';\n\n        img.onload = function () {\n          charElement.attr('src', actualSpriteUrl);\n          charElement.attr('alt', character);\n          charElement.css('display', 'block');\n\n          if (imageInfo.type === 'char') {\n            charElement.css({\n              'max-height': '120%',\n              'max-width': '100%',\n              bottom: `${config.characterBottomOffset}%`,\n            });\n          }\n\n          charElement.addClass('active');\n\n          // 使其他角色变暗\n          for (const p in streamInfo.characters) {\n            if (p !== position && streamInfo.characters[p].name) {\n              const otherPos =\n                p === 'L'\n                  ? streamInfo.leftCharElement\n                  : p === 'C'\n                  ? streamInfo.centerCharElement\n                  : streamInfo.rightCharElement;\n              otherPos.addClass('dimmed');\n            }\n          }\n        };\n\n        img.onerror = function () {\n          charElement.attr(\n            'src',\n            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=',\n          );\n          charElement.attr('alt', character + ' (图片加载失败)');\n          charElement.css('display', 'block');\n          charElement.addClass('active');\n\n          // 使其他角色变暗\n          for (const p in streamInfo.characters) {\n            if (p !== position && streamInfo.characters[p].name) {\n              const otherPos =\n                p === 'L'\n                  ? streamInfo.leftCharElement\n                  : p === 'C'\n                  ? streamInfo.centerCharElement\n                  : streamInfo.rightCharElement;\n              otherPos.addClass('dimmed');\n            }\n          }\n        };\n\n        img.src = actualSpriteUrl;\n      } else {\n        // 无图片时也显示角色\n        charElement.attr(\n          'src',\n          'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=',\n        );\n        charElement.attr('alt', character + ' (图片未设置)');\n        charElement.css('display', 'block');\n        charElement.addClass('active');\n\n        // 使其他角色变暗\n        for (const p in streamInfo.characters) {\n          if (p !== position && streamInfo.characters[p].name) {\n            const otherPos =\n              p === 'L'\n                ? streamInfo.leftCharElement\n                : p === 'C'\n                ? streamInfo.centerCharElement\n                : streamInfo.rightCharElement;\n            otherPos.addClass('dimmed');\n          }\n        }\n      }\n    } catch (error) {\n      log('处理流式角色出错:', error);\n    }\n  }\n\n  // 隐藏流式角色\n  function hideStreamCharacter(target) {\n    try {\n      if (!streamInfo) return;\n\n      // 如果是位置 (L, C, R)\n      if (['L', 'C', 'R'].includes(target)) {\n        let charElement = null;\n\n        if (target === 'L') {\n          charElement = streamInfo.leftCharElement;\n        } else if (target === 'C') {\n          charElement = streamInfo.centerCharElement;\n        } else if (target === 'R') {\n          charElement = streamInfo.rightCharElement;\n        }\n\n        if (charElement && charElement.length) {\n          charElement.removeClass('active dimmed');\n          streamInfo.characters[target] = { name: null, sprite: null };\n        }\n      }\n      // 如果是角色名\n      else {\n        for (const p in streamInfo.characters) {\n          if (streamInfo.characters[p] && streamInfo.characters[p].name === target) {\n            const pos = p === 'L' ? 'left' : p === 'C' ? 'center' : 'right';\n            const charElement =\n              p === 'L'\n                ? streamInfo.leftCharElement\n                : p === 'C'\n                ? streamInfo.centerCharElement\n                : streamInfo.rightCharElement;\n\n            if (charElement && charElement.length) {\n              charElement.removeClass('active dimmed');\n              streamInfo.characters[p] = { name: null, sprite: null };\n            }\n          }\n        }\n      }\n    } catch (error) {\n      log('隐藏流式角色出错:', error);\n    }\n  }\n\n  // 显示流式CG\n  function showStreamCG(cgUrl) {\n    try {\n      if (!streamInfo || !streamInfo.cgElement) return;\n\n      // 处理CG URL\n      const imageInfo = resolveImageUrl(cgUrl, 'cg');\n      const actualCgUrl = imageInfo ? imageInfo.url : null;\n\n      if (actualCgUrl && actualCgUrl.startsWith('http')) {\n        const img = new Image();\n        img.crossOrigin = 'anonymous';\n\n        img.onload = function () {\n          streamInfo.cgElement.find('img').attr('src', actualCgUrl);\n          streamInfo.cgElement.addClass('active');\n        };\n\n        img.onerror = function () {\n          streamInfo.cgElement.removeClass('active');\n        };\n\n        img.src = actualCgUrl;\n      } else {\n        streamInfo.cgElement.removeClass('active');\n      }\n    } catch (error) {\n      log('显示流式CG出错:', error);\n    }\n  }\n\n  // 隐藏流式CG\n  function hideStreamCG() {\n    try {\n      if (!streamInfo || !streamInfo.cgElement) return;\n\n      streamInfo.cgElement.removeClass('active');\n    } catch (error) {\n      log('隐藏流式CG出错:', error);\n    }\n  }\n\n  // 添加流式对话到履历\n  function addStreamToHistory(messageId, speaker, text) {\n    if (!streamInfo || !streamInfo.history) return;\n\n    streamInfo.history.push({\n      speaker: speaker || '旁白',\n      text: text,\n    });\n\n    if (streamInfo.history.length > 100) {\n      streamInfo.history.shift();\n    }\n  }\n\n  // 显示流式履历\n  function showStreamHistoryModal(messageId) {\n    if (!streamInfo || !streamInfo.history || !streamInfo.historyListElement) return;\n\n    streamInfo.historyListElement.empty();\n\n    for (let i = 0; i < streamInfo.history.length; i++) {\n      const item = streamInfo.history[i];\n      const itemElement = $(`\n        <div class=\"galgame-history-item-${messageId}\">\n          <div class=\"galgame-history-speaker-${messageId}\">${item.speaker}</div>\n          <div class=\"galgame-history-text-${messageId}\">${item.text}</div>\n        </div>\n      `);\n      streamInfo.historyListElement.append(itemElement);\n    }\n\n    $(`#history-modal-stream-${messageId}`).css('display', 'block');\n\n    const historyContent = $(`#history-modal-stream-${messageId} .galgame-history-content-${messageId}`);\n    historyContent.scrollTop(historyContent[0].scrollHeight);\n  }\n\n  // 隐藏流式履历\n  function hideStreamHistoryModal(messageId) {\n    $(`#history-modal-stream-${messageId}`).css('display', 'none');\n  }\n\n  // 重新开始流式对话\n  function restartStreamDialogue() {\n    if (!streamInfo) return;\n\n    // 重置对话索引\n    streamInfo.currentDialogIndex = 0;\n\n    // 清除文本\n    streamInfo.textElement.text('');\n\n    // 移除重新播放按钮\n    $(`.galgame-dialogue-${streamInfo.mesid} .replay-button`, tempMesText).remove();\n\n    // 重置角色\n    streamInfo.characters = {\n      L: { name: null, sprite: null },\n      C: { name: null, sprite: null },\n      R: { name: null, sprite: null },\n    };\n\n    // 隐藏所有角色\n    streamInfo.leftCharElement.removeClass('active dimmed');\n    streamInfo.centerCharElement.removeClass('active dimmed');\n    streamInfo.rightCharElement.removeClass('active dimmed');\n\n    // 隐藏CG\n    streamInfo.cgElement.removeClass('active');\n\n    // 重置背景\n    streamInfo.sceneElement.css({\n      'background-image': 'none',\n      'background-color': '#000',\n    });\n\n    // 隐藏角色名\n    streamInfo.nameElement.hide();\n\n    // 重置转场效果\n    streamInfo.overlayElement.css({\n      opacity: '0',\n      transition: 'none',\n    });\n\n    // 显示下一步指示器\n    streamInfo.nextElement.show();\n\n    // 开始处理第一条对话\n    streamInfo.processing = false;\n    processStreamNextDialogue();\n  }\n\n  // 添加一个新函数处理流式生成完成后的操作\n  function finishStreamGeneration() {\n    try {\n      if (!streamInfo || !streamInfo.isComplete) return;\n\n      // 防止重复处理\n      if (streamInfo.finishProcessed) return;\n      streamInfo.finishProcessed = true;\n\n      // 设置一个标志，表示当前正在完成处理\n      window.GALGAME_FINISHING_STREAM = true;\n\n      // 确保原始消息元素存在\n      if (streamInfo.originalMessageEl && streamInfo.originalMessageEl.length > 0) {\n        // 更新原始消息元素的内容\n        if (streamInfo.text) {\n          // 从临时UI复制内容而不只是文本\n          const gameContent = tempMesText ? tempMesText.html() : null;\n\n          // 更新原始消息元素文本\n          streamInfo.originalMessageEl.text(streamInfo.text);\n\n          // 标记已完成状态\n          streamInfo.originalMessageEl.attr('data-stream-complete', 'true');\n\n          // 尝试创建一个隐藏的备份元素，确保内容在DOM中存在\n          const backupId = `stream-backup-${streamInfo.mesid}`;\n          if ($(`#${backupId}`).length === 0) {\n            const backup = $(`<div id=\"${backupId}\" style=\"display:none;\">${streamInfo.text}</div>`);\n            $('body').append(backup);\n\n            // 设置5秒后自动删除\n            setTimeout(() => {\n              try {\n                $(`#${backupId}`).remove();\n              } catch (e) {}\n            }, 5000);\n          }\n        }\n      }\n\n      // 标记完成状态，以便其他功能可以正确识别\n      if (streamInfo) {\n        streamInfo.generationComplete = true;\n      }\n\n      // 阻止界面刷新，设置一个延迟标志\n      setTimeout(() => {\n        window.GALGAME_FINISHING_STREAM = false;\n      }, 2000); // 给系统足够的时间处理其他事件后再清除标志\n\n      // 设置DOM处理完毕的标志\n      streamInfo.domProcessComplete = true;\n    } catch (error) {\n      window.GALGAME_FINISHING_STREAM = false;\n      log('完成流式生成更新时出错:', error);\n    }\n  }\n\n  // 添加一个新函数强制重置流式消息状态\n  function forceResetStreamMessage(mesId) {\n    try {\n      if (!streamInfo || streamInfo.mesid !== Number(mesId)) return;\n\n      // 确保原始消息元素内容正确\n      if (streamInfo.originalMessageEl && streamInfo.originalMessageEl.length > 0) {\n        // 移除所有自定义属性\n        streamInfo.originalMessageEl.removeAttr('style');\n        streamInfo.originalMessageEl.removeAttr('data-stream-complete');\n\n        // 更新内容并显示原始消息\n        if (streamInfo.text) {\n          streamInfo.originalMessageEl.text(streamInfo.text);\n        }\n        streamInfo.originalMessageEl.css('display', 'block');\n      }\n\n      // 移除临时UI\n      if (tempMesText) {\n        tempMesText.remove();\n        tempMesText = null;\n      }\n\n      // 清除游戏状态\n      if (renderedMessages.has(String(mesId))) {\n        renderedMessages.delete(String(mesId));\n      }\n\n      if (gameStates[mesId]) {\n        delete gameStates[mesId];\n      }\n\n      // 重置流式状态\n      streamInfo = undefined;\n      streamStart = false;\n      streamParsing = false;\n\n      // 清除全局标志\n      window.GALGAME_FINISHING_STREAM = false;\n      window.GALGAME_EDITING_MESSAGE = false;\n    } catch (error) {\n      log('强制重置流式消息状态失败:', error);\n    }\n  }\n\n  // 清理超出渲染深度的GALGAME界面\n  function cleanupOldRenders(lastMessageId) {\n    try {\n      if (config.renderDepth <= 0) return; // 如果没有设置渲染深度限制，则不需要清理\n\n      log('清理超出渲染深度的GALGAME界面');\n\n      // 查找所有已渲染的消息\n      $('#chat .mes').each(function () {\n        const mesid = Number($(this).attr('mesid') || $(this).attr('data-mesid') || $(this).attr('data-id'));\n        if (!isNaN(mesid) && mesid > 0) {\n          // 检查是否超出渲染深度\n          if (lastMessageId - mesid >= config.renderDepth) {\n            // 从渲染集合中移除\n            if (renderedMessages.has(mesid.toString())) {\n              renderedMessages.delete(mesid.toString());\n            }\n\n            // 删除该消息的gameStates\n            if (gameStates[mesid]) {\n              delete gameStates[mesid];\n            }\n\n            // 移除GALGAME界面\n            $(this).find('.roleplay_galgame').remove();\n\n            log('清理了消息的GALGAME界面:', mesid);\n          }\n        }\n      });\n    } catch (error) {\n      log('清理旧渲染时出错:', error);\n    }\n  }\n\n  // 获取最新消息ID\n  async function getLastMessageId() {\n    try {\n      // 尝试从DOM中获取\n      const $lastMessage = $('#chat .mes').last();\n      if ($lastMessage.length > 0) {\n        const mesid = Number(\n          $lastMessage.attr('mesid') || $lastMessage.attr('data-mesid') || $lastMessage.attr('data-id'),\n        );\n        if (!isNaN(mesid) && mesid > 0) {\n          return mesid;\n        }\n      }\n\n      // 如果DOM中获取失败，尝试通过API获取\n      try {\n        return Number(await triggerSlashWithResult('/pass {{lastMessageId}}'));\n      } catch (e) {\n        log('通过API获取最新消息ID失败:', e);\n      }\n\n      // 所有方法都失败，返回0\n      return 0;\n    } catch (error) {\n      log('获取最新消息ID时出错:', error);\n      return 0;\n    }\n  }\n\n  // 获取图片URL (新增的辅助函数)\n  function resolveImageUrl(urlOrAlias, type = 'char') {\n    if (!urlOrAlias || typeof urlOrAlias !== 'string') return null;\n\n    // 处理[type|别名]格式\n    const tagRegex = new RegExp(`\\\\[(${type}|[a-z]+)\\\\|([^\\\\]]+)\\\\]`);\n    const match = urlOrAlias.match(tagRegex);\n\n    if (match) {\n      const actualType = match[1];\n      const alias = match[2].trim();\n\n      const aliasObj = imageAliasManager.getAliases ? imageAliasManager.getAliases() : {};\n      if (aliasObj && alias in aliasObj) {\n        return {\n          url: aliasObj[alias],\n          type: actualType,\n        };\n      }\n      return { url: null, type: actualType };\n    }\n\n    // 直接使用别名或URL\n    const aliasObj = imageAliasManager.getAliases ? imageAliasManager.getAliases() : {};\n    if (aliasObj && urlOrAlias in aliasObj) {\n      return {\n        url: aliasObj[urlOrAlias],\n        type: type,\n      };\n    } else if (urlOrAlias.startsWith('http://') || urlOrAlias.startsWith('https://')) {\n      return {\n        url: urlOrAlias,\n        type: type,\n      };\n    }\n\n    return { url: null, type: type };\n  }\n})();\n",
